///*
// * generated by Xtext 2.25.0
// */
package ca.uottawa.csmlab.symboleo.generator
 
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ca.uottawa.csmlab.symboleo.symboleo.DomainType
import ca.uottawa.csmlab.symboleo.symboleo.RegularType
import ca.uottawa.csmlab.symboleo.symboleo.Attribute
//import ca.uottawa.csmlab.symboleo.symboleo.ACPolicy
import ca.uottawa.csmlab.symboleo.symboleo.Permission
 
import java.util.List
import ca.uottawa.csmlab.symboleo.symboleo.Model
import java.util.ArrayList
import ca.uottawa.csmlab.symboleo.symboleo.Enumeration
import ca.uottawa.csmlab.symboleo.symboleo.Parameter
//import ca.uottawa.csmlab.symboleo.symboleo.AssignVariable
import ca.uottawa.csmlab.symboleo.symboleo.VariableRef
import ca.uottawa.csmlab.symboleo.symboleo.Ref
import ca.uottawa.csmlab.symboleo.symboleo.VariableDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.AssignExpression
import ca.uottawa.csmlab.symboleo.symboleo.OAssignExpression
import ca.uottawa.csmlab.symboleo.symboleo.Expression
import ca.uottawa.csmlab.symboleo.symboleo.And
import ca.uottawa.csmlab.symboleo.symboleo.Or
import ca.uottawa.csmlab.symboleo.symboleo.Equality
import ca.uottawa.csmlab.symboleo.symboleo.Comparison
import ca.uottawa.csmlab.symboleo.symboleo.Plus
import ca.uottawa.csmlab.symboleo.symboleo.Minus
import ca.uottawa.csmlab.symboleo.symboleo.Div
import ca.uottawa.csmlab.symboleo.symboleo.Multi
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionFunctionCall
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPrimaryExpression
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionTrue
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionFalse
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDouble
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionInt
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionEnum
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionString
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionParameter
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionRecursive
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.Obligation
import ca.uottawa.csmlab.symboleo.symboleo.Power
import ca.uottawa.csmlab.symboleo.symboleo.Variable;
//AC
import ca.uottawa.csmlab.symboleo.symboleo.Controller;
//import ca.uottawa.csmlab.symboleo.symboleo.ACPolicy;
//-----
import ca.uottawa.csmlab.symboleo.symboleo.Proposition
import ca.uottawa.csmlab.symboleo.symboleo.POr
import ca.uottawa.csmlab.symboleo.symboleo.PAnd
import ca.uottawa.csmlab.symboleo.symboleo.PEquality
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPAtom
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomEnum
import ca.uottawa.csmlab.symboleo.symboleo.PAtomRecursive
import ca.uottawa.csmlab.symboleo.symboleo.PComparison
import ca.uottawa.csmlab.symboleo.symboleo.PArithmetic
import ca.uottawa.csmlab.symboleo.symboleo.PAtomVariable
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateTrueLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateFalseLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomIntLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomStringLiteral
import java.util.HashMap
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDoubleLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunction
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappens
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensWithin
import ca.uottawa.csmlab.symboleo.symboleo.Event
import ca.uottawa.csmlab.symboleo.symboleo.VariableEvent
import ca.uottawa.csmlab.symboleo.symboleo.PowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.ObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.ContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationSuspended
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationResumed
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationDischarged
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTerminated
import ca.uottawa.csmlab.symboleo.symboleo.PFContractSuspended
import ca.uottawa.csmlab.symboleo.symboleo.PFContractResumed
import ca.uottawa.csmlab.symboleo.symboleo.PFContractTerminated
import ca.uottawa.csmlab.symboleo.symboleo.Interval
import ca.uottawa.csmlab.symboleo.symboleo.Point
import ca.uottawa.csmlab.symboleo.symboleo.PointExpression
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomParameterDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.PointFunction
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PointAtomPowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.IntervalExpression
import ca.uottawa.csmlab.symboleo.symboleo.IntervalFunction
import ca.uottawa.csmlab.symboleo.symboleo.Situation
import ca.uottawa.csmlab.symboleo.symboleo.ObligationState
import ca.uottawa.csmlab.symboleo.symboleo.PowerState
import ca.uottawa.csmlab.symboleo.symboleo.ContractState
import ca.uottawa.csmlab.symboleo.symboleo.SituationExpression
import ca.uottawa.csmlab.symboleo.symboleo.Timevalue
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueInt
import ca.uottawa.csmlab.symboleo.symboleo.TimevalueVariable
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.ThreeArgDateFunction
import ca.uottawa.csmlab.symboleo.Helpers
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionSHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionWHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.OntologyType
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDateLiteral
import java.time.format.DateTimeFormatter
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensAfter
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionAssignment
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionAssignmentOnly
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTriggered
import ca.uottawa.csmlab.symboleo.symboleo.Assignment
import ca.uottawa.csmlab.symboleo.symboleo.OAssignment
import ca.uottawa.csmlab.symboleo.generator.SymboleoGenerator
import ca.uottawa.csmlab.symboleo.symboleo.Mod
 
//AC
import ca.uottawa.csmlab.symboleo.symboleo.Rule
import ca.uottawa.csmlab.symboleo.symboleo.ResourcePower
import ca.uottawa.csmlab.symboleo.symboleo.ResourceObligation
import ca.uottawa.csmlab.symboleo.symboleo.ResourceOntologyType
import ca.uottawa.csmlab.symboleo.symboleo.ResourceACPolicy
import ca.uottawa.csmlab.symboleo.symboleo.ResourceDot
import ca.uottawa.csmlab.symboleo.symboleo.ResourceAttribute
import ca.uottawa.csmlab.symboleo.symboleo.PowerFunction

class Symboleo2SC extends SymboleoGenerator {
 
  val ASSET_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val EVENT_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val ROLE_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val POWER_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val OBLIGATION_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val CONTRACT_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val EVENTS_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val PREDICATES_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val UTILS_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val ACPolicy_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val ATTRIBUTE_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val Rule_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val Resource_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val Operation_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
 val LegalSituation_CLASS_IMPORT_PATH = "\"symboleo-js-core\""
  val assets = new ArrayList<RegularType>
  val events = new ArrayList<RegularType>
  val roles = new ArrayList<RegularType>
  val enumerations = new ArrayList<Enumeration>
  val parameters= new ArrayList<Parameter>
  val variables = new ArrayList<Variable>
  val AssignVar= new ArrayList<String>
  
  val conditionalObligations = new ArrayList<Obligation>
  val conditionalSurvivingObligations = new ArrayList<Obligation>
  val conditionalPowers = new ArrayList<Power>
  
  val unconditionalObligations = new ArrayList<Obligation>
  val unconditionalSurvivingObligations = new ArrayList<Obligation>
  val unconditionalPowers = new ArrayList<Power>
  
  val untriggeredObligations = new ArrayList<Obligation>
  val untriggeredSurvivingObligations = new ArrayList<Obligation>
  val untriggeredPowers = new ArrayList<Power>
  
  val triggeredObligations = new ArrayList<Obligation>
  val triggeredSurvivingObligations = new ArrayList<Obligation>
  val triggeredPowers = new ArrayList<Power>
  
  val allObligations = new ArrayList<Obligation>
  val allSurvivingObligations = new ArrayList<Obligation>
  val allPowers = new ArrayList<Power>
  val arrays = new ArrayList<String>
  val eventVariables = new ArrayList<Variable>
 
  val obligationTriggerEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val survivingObligationTriggerEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val powerTriggerEvents = new HashMap<Power, List<PAtomPredicate>>
 
  val obligationAntecedentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val survivingObligationAntecedentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val powerAntecedentEvents = new HashMap<Power, List<PAtomPredicate>>
 
  val obligationFullfilmentEvents = new HashMap<Obligation, List<PAtomPredicate>>
  val survivingObligationFullfilmentEvents = new HashMap<Obligation, List<PAtomPredicate>>
   // AC
  val controller =  new HashMap<Resource, List<Controller>>
	
 
 
  def void generateHFSource(IFileSystemAccess2 fsa, Model model) {
    parse(model)
    compileDomainTypes(fsa, model)
    compileContract(fsa, model)
    compileEventsFile(fsa, model)
    compileTransactionFile(fsa, model)
    compileSerializerFile(fsa, model)
    generateNPMFile(fsa, model)
  }  
  //
    def void compileDomainTypes(IFileSystemAccess2 fsa, Model model) {
    for (asset : assets) {
      generateAsset(fsa, model, asset)
    }
    for (event : events) {
      generateEvent(fsa, model, event)
    }
    for (role : roles) {
      generateRole(fsa, model, role)
    }
 
    for (enumeration : enumerations) {
      generateEnumeration(fsa, model, enumeration)
    }
  }
  //
  def void compileContract(IFileSystemAccess2 fsa, Model model) {
    val code = '''
      «FOR asset : assets»
        const { «asset.name» } = require("../assets/«asset.name».js")
      «ENDFOR»
      «FOR event : events»
        const { «event.name» } = require("../events/«event.name».js")
      «ENDFOR»
      «FOR role : roles»
        const { «role.name» } = require("../roles/«role.name».js")
      «ENDFOR»
      «FOR enumeration : enumerations»
        const { «enumeration.name» } = require("../types/«enumeration.name».js")
      «ENDFOR»
      const { SymboleoContract } = require(«CONTRACT_CLASS_IMPORT_PATH»)
      const { Obligation } = require(«OBLIGATION_CLASS_IMPORT_PATH»)
      const { Power } = require(«POWER_CLASS_IMPORT_PATH»)
      const { Utils } = require(«UTILS_CLASS_IMPORT_PATH»)
      const { Str } = require(«UTILS_CLASS_IMPORT_PATH»)
      const { ACPolicy } = require(«ACPolicy_CLASS_IMPORT_PATH»)
      const { Notified } = require("../events/Notified.js")
      const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»)
      const { Rule } = require(«Rule_CLASS_IMPORT_PATH»)
      const { LegalSituation } = require(«LegalSituation_CLASS_IMPORT_PATH»)
      const { contracts } = require("../../index.js")
      
      class «model.contractName» extends SymboleoContract {
        constructor(«model.parameters.map[Parameter p | p.name].join(', ')») {
          super("«model.contractName»")
          this._name = "«model.contractName»"
          «FOR parameter : model.parameters»
            this.«parameter.name» = «parameter.name»
          «ENDFOR»
          
          this.obligations = {};
          this.survivingObligations = {};
          this.powers = {};
          
          // assign varaibles of the contract
          «FOR variable : model.variables»
            «IF variable.type instanceof RegularType»
              		this.«variable.name» = new «variable.type.name»("«variable.name»")
              
              «var cntt=0»
               «var cntp=""»
              «FOR assignment: variable.attributes»
                «IF assignment instanceof AssignExpression »
                 «IF assignment.name != 'controller' && assignment.name != 'performer'»
              		 this.«variable.name».«assignment.name»._value = «generateExpressionString(assignment.value, 'this')»
                  «ELSE»
                    «IF assignment.name == 'controller'»
                 «{ cntt = 1; "" }»  
           			 this.«variable.name».addConroller(«generateExpressionString(assignment.value, 'this')»)
                    «ELSE»
                     «Helpers.getBaseType(variable.type).ontologyType.name=='Event'? "this."+variable.name+".addPerformer("+generateExpressionString(assignment.value, 'this')+")" :"" »
                 «ENDIF»
                 «ENDIF»
                 «ENDIF»
              «ENDFOR»
               «IF cntt == 0»
               	 this.«variable.name».addConroller(«getDefaultController(model,variable)»)  
                «ENDIF»
               	 «Helpers.getBaseType(variable.type).ontologyType.name=='Role'? "this.addRole(this."+variable.name+")" :"" »
            «ENDIF»         
          «ENDFOR»
          		 this.aCPolicy = new ACPolicy(«getDefaultControllerACPolicy(model)»)
          «FOR variable : model.variables» 
              «IF findRole(variable.type.name)»
                 this.addController(this.«variable.name»);
          	 «ENDIF»    
          «ENDFOR»
          // create instance of triggered obligations
          «FOR obligation : triggeredObligations»
          	    this.«obligation.name»Situation = new LegalSituation();
          	  «IF !(obligation.consequent instanceof PAtomPredicateTrueLiteral)»
          	   «generateLegalpositionCondition(obligation.consequent,"this."+obligation.name+"Situation.addConsequentOf(")» 
              «ENDIF»
              «IF !(obligation.antecedent instanceof PAtomPredicateTrueLiteral)»
               «generateLegalpositionCondition(obligation.antecedent,"this."+obligation.name+"Situation.addAntecedentOf(")» 
           	  «ENDIF»
                this.obligations.«obligation.name» = new Obligation('«obligation.name»', «generateDotExpressionString(obligation.creditor, 'this')», «generateDotExpressionString(obligation.debtor, 'this')», this, this.«obligation.name»Situation)
                «getSpecifiedControllerObligation(obligation)»
          «ENDFOR»
          
          «FOR obligation : triggeredSurvivingObligations»
                this.survivingObligations.«obligation.name» = new Obligation('«obligation.name»', «generateDotExpressionString(obligation.creditor, 'this')», «generateDotExpressionString(obligation.debtor, 'this')», this, true,this.«obligation.name»Situation)
                «getSpecifiedControllerObligation(obligation)»
          «ENDFOR»
          
          «FOR power : triggeredPowers»
            	this.«power.name»Situation = new LegalSituation();            
           «IF !(power.antecedent instanceof PAtomPredicateTrueLiteral)»
               «generateLegalpositionCondition(power.antecedent,"this."+power.name+"Situation.addAntecedentOf(")» 
           «ENDIF»
            	this.«power.name»Situation.addConsequentOf({_type: 'stateCondition',«compilePowerCondition(power.consequent)»})
            	this.powers.«power.name» = new Power('«power.name»', «generateDotExpressionString(power.creditor, 'this')», «generateDotExpressionString(power.debtor, 'this')», this,this.«power.name»Situation)
            	«getSpecifiedControllerPower(power)»  
          «ENDFOR»
        
         «FOR rule : model.rules»
        		«getSpecifiedRulesUnCond(rule)»
        «ENDFOR»
     	}
    }
      
      module.exports.«model.contractName» = «model.contractName»
    '''
    fsa.generateFile("./" + model.contractName + "/domain/contract/" + model.contractName + ".js", code)
  }
  
  // {_type: 'stateCondition', resourceType:"obligation", resource: "delivery", state:"Fulfilled"}
   def void compileTransactionFile(IFileSystemAccess2 fsa, Model model) {
    val code = '''
      const { Contract } = require("fabric-contract-api")
      const { «model.contractName» } = require("./domain/contract/«model.contractName».js")
      const { deserialize, serialize } = require("./serializer.js")
      const { Events } = require(«EVENT_CLASS_IMPORT_PATH»)
      const { InternalEvent, InternalEventSource, InternalEventType } = require(«EVENT_CLASS_IMPORT_PATH»)
      const { getEventMap, EventListeners } = require("./events.js")
      const { Rule } = require(«Rule_CLASS_IMPORT_PATH»)
      const { error } = require("fabric-shim")
«««      «FOR asset : assets»
«««        import { «asset.name» } = require( "./domain/assets/«asset.name»")
«««      «ENDFOR»
«««      «FOR event : events»
«««        const { «event.name» } = require( "./domain/events/«event.name»")
«««      «ENDFOR»
«««      «FOR role : roles»
«««        const { «role.name» } = require( "./domain/roles/«role.name»")
«««      «ENDFOR»
«««      «FOR enumeration : enumerations»
«««        const { «enumeration.name» } = require( "./domain/types/«enumeration.name»")
«««      «ENDFOR»
      class HFContract extends Contract {
        
        constructor() {
          super('«model.contractName»');
        }
      
        initialize(contract) {
          Events.init(getEventMap(contract), EventListeners)
        }
      
        «compileInitMethod(model)»
      
        «FOR method : compileEventTriggerMethods(model)»
          «method»
          
        «ENDFOR»
        «FOR method : compilePowerTransactions(model)»
          «method»
          
        «ENDFOR»
        «FOR method : compileViolationEventsTransactions(model)»
          «method»
          
        «ENDFOR»
        «FOR method : compileExpirationTransactions(model)»
          «method»
          
        «ENDFOR»
        «FOR method : compilePowerExpirationTransactions(model)»
          «method»
          
        «ENDFOR»
        
        //get Date And Time of any event
        async getEventDateAndTime(ctx, args) {
            const inputs = JSON.parse(args);
            const contractId = inputs.contractId;
            const requiredResource = inputs.event
            let output = {}
            const contractState = await ctx.stub.getState(contractId)
            if (contractState == null) {
              return {successful: false}
            }
            const contract = deserialize(contractState.toString())
            this.initialize(contract)
            let eventObj = contract.findObject(requiredResource.event, requiredResource._type, contract)
            if (  eventObj != null){
            if(contract.accessPolicy.hasPermesstion('grant','read', eventObj, contract.shipper, contract.shipper) || contract.accessPolicy.hasPermesstionOnLegalPosition('grant','read', eventObj, contract.seller, contract.seller,contract)){
              output = {time: eventObj.getHappenedTime(), state: eventObj.hasHappened()  ? "Happened" : "Not Happened"}  
            }else{
              throw new Error(`access denied...`)
            }
            return output
            }else{ throw new Error(`The event is not exist...`)}
          }
      
        //AC -- access state, time for legalpositions (obligation and power) by authorized roles 
        async getLegalPositionStateAndTime(ctx, args) {
          const inputs = JSON.parse(args);
          const contractId = inputs.contractId;
          const quiredState = inputs.quiredState.state
          const requiredResource = inputs.quiredState.resource
          const requiredResourceType = inputs.quiredState.resourceType
      
          let output = {}
        	const contractState = await ctx.stub.getState(contractId)
        	if (contractState == null) {
        	  return {successful: false}
        	}
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
      
          const aResource = contract.findLegalPosition(requiredResource, requiredResourceType, contract)
          if(aResource !== null){
            switch(requiredResourceType.toLowerCase()){
             case 'obligation':
               if(contract.accessPolicy.hasPermesstion('grant','read', aResource, contract.seller, contract.seller)) {
                   output= contract.findStateTimeLegalPosition(aResource)
          }else{
            throw new Error(`access denied...`)
          }
          break
          case 'power': 
            if(contract.accessPolicy.hasPermesstion('grant','read', aResource, contract.seller, contract.seller)) {
                 output=contract.findStateTimeLegalPosition(aResource)
            }else{
              throw new Error(`access denied...`)
            }
          }// outer switch
          } else{throw new Error(`Resource is not exist...`)}//if (aResource == null)
        
          return output
          
        }
        
        // Access the state and time of the parts of the legalpositions
        async getStateTimeOfParts(ctx, args){
         const inputs = JSON.parse(args);
         const contractId = inputs.contractId;
         const requiredResource = inputs.condition
        
         let output = {}
        
         const contractState = await ctx.stub.getState(contractId)
         if (contractState == null) {
           return {successful: false}
         }
        
         const contract = deserialize(contractState.toString())
         this.initialize(contract)
         const aLegalPositionIncodition = contract.findLegalPosition(requiredResource.resource, requiredResource.resourceType, contract)
         if(aLegalPositionIncodition !==null){
            switch(requiredResource._type.toLowerCase()){
              case 'statecondition':          
                if(contract.accessPolicy.hasPermesstionOnLegalPosition('grant','read', requiredResource, contract.buyer, contract.seller,contract)){
                  output=contract.findStateTimeLegalPosition(aLegalPositionIncodition)
                   if(output.State !== null && output.State !== undefined ){
                     if (output.State.toLowerCase() !== requiredResource.state.toLowerCase() ) {
                          output = {state: requiredResource.state.toLowerCase()+' is Not Happened', time: null}
                       }
                     }
                } else{
                    throw new Error(`access denied...`)
                }
              break
              
              case 'condition': 
                if(contract.accessPolicy.hasPermesstionOnLegalPosition('grant','read', requiredResource, contract.seller, contract.seller,contract)){
                  let conditionValue = eval('contract.'+requiredResource.leftSide + " " + requiredResource.op + " " + requiredResource.rightSide)
                  output = {state: conditionValue, time: null}
                }else{
                      throw new Error(`access denied...`)
                }
              break
            
              case 'eventcondition':
                if(contract.accessPolicy.hasPermesstionOnLegalPosition('grant','read', requiredResource, contract.seller, contract.seller,contract)){
                   let eventObj = contract.findObject(requiredResource.partResource, requiredResource.partResourceType, contract)
                   output = {time: eventObj.getHappenedTime(), state: eventObj.hasHappened()  ? "Happened" : "Not Happened"}
                }else{
                     throw new Error(`access denied...`)
                }
              break
              
              default: throw new Error(`This is not a valid part of legal situation...`)
            }
            
         }else {throw new Error(`Resource is not exist...`)}
        
         return output
        
        }
        
       // Return the states of the contract and its parts     
        async getState(ctx, contractId) {
        	const contractState = await ctx.stub.getState(contractId)
        	if (contractState == null) {
        	  return {successful: false}
        	}
        	const contract = deserialize(contractState.toString())
        	this.initialize(contract)
        	let output = `Contract state: ${contract.state}-${contract.activeState}\r\n`
        	output += 'Obligations:\r\n'
        	for (const obligationKey of Object.keys(contract.obligations)) {
            output += `  ${obligationKey}: ${contract.obligations[obligationKey].state}-${contract.obligations[obligationKey].activeState}\r\n`
          }
          output += 'Powers:\r\n'
          for (const powerKey of Object.keys(contract.powers)) {
            output += `  ${powerKey}: ${contract.powers[powerKey].state}-${contract.powers[powerKey].activeState}\r\n`
          }
          output += 'Surviving Obligations:\r\n'
          for (const obligationKey of Object.keys(contract.survivingObligations)) {
            output += `  ${obligationKey}: ${contract.survivingObligations[obligationKey].state}-${contract.survivingObligations[obligationKey].activeState}\r\n`
          }
          output += 'Events:\r\n'
          «FOR event : eventVariables»
            if (contract.«event.name»._triggered) {
              output += `  Event "«event.name»" happened at ${contract.«event.name»._timestamp}\r\n`
            } else {
              output += `  Event "«event.name»" has not happened\r\n`
            }
          «ENDFOR»
          
          return output
        }
      }
      
      module.exports.contracts = [HFContract];
    '''
    fsa.generateFile("./" + model.contractName + "/" + "index.js", code)
  }
//
def void generateAsset(IFileSystemAccess2 fsa, Model model, RegularType asset) {
    val isBase = asset.ontologyType !== null
 
    if (isBase === true) {
      val code = '''
        const { Asset } = require(«ASSET_CLASS_IMPORT_PATH»);
        const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»);
        
        class «asset.name» extends Asset {
          constructor(_name,owner,«asset.attributes.map[Attribute a | a.name].join(', ')») {
            super(owner)
            this._name = _name
            this._type = "«asset.name»"
            «FOR attribute : asset.attributes»
             «IF (attribute.name !='owner' && attribute.name !='controller')»
             this.«attribute.name» = new Attribute("«attribute.name»",«attribute.name»)
              «ENDIF»
            «ENDFOR»
          }
        }
        
        module.exports.«asset.name» = «asset.name»
      '''
      fsa.generateFile("./" + model.contractName + "/domain/assets/" + asset.name + ".js", code)
    } else if (asset.regularType !== null) {
      val parentType = asset.regularType
      val allAttributes = Helpers.getAttributesOfRegularType(asset)
      val parentAttributes = new ArrayList<Attribute>(allAttributes)
      parentAttributes.removeAll(asset.attributes)
      val code = '''
        const { «parentType.name» } = require("./«parentType.name».js");
        const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»);
        
        class «asset.name» extends «parentType.name» {
          constructor(_name,owner,«allAttributes.map[Attribute a | a.name].join(', ')») {
            super(_name,owner,«parentAttributes.map[Attribute a | a.name].join(', ')»)
            this._type = "«asset.name»"
            «FOR attribute : asset.attributes»
             «IF (attribute.name !='owner' && attribute.name !='controller')»
                 this.«attribute.name» = new Attribute("«attribute.name»",«attribute.name»)
             «ENDIF»
            «ENDFOR»
            
          }
        }
        
        module.exports.«asset.name» = «asset.name»
      '''
      fsa.generateFile("./" + model.contractName + "/domain/assets/" + asset.name + ".js", code)
    }
  }
  
  //
   def void generateEvent(IFileSystemAccess2 fsa, Model model, RegularType event) {
    val isBase = event.ontologyType !== null
 
    if (isBase === true) {
      val code = '''
        const { Event } = require(«EVENT_CLASS_IMPORT_PATH»);
        const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»);
        class «event.name» extends Event {
         	constructor(_name,performer,«event.attributes.filter[Attribute a | a.name != "performer" && a.name != "controller"].map[Attribute a | a.name].join(', ')» ) {
            super(performer)
            this._name = _name
            this._type = "«event.name»"
            «FOR attribute : event.attributes»
             «IF (attribute.name !='performer' && attribute.name !='controller')»
             this.«attribute.name» = new Attribute("«attribute.name»",«attribute.name»)
            «ENDIF»
            «ENDFOR»
          }
        }
        
        module.exports.«event.name» = «event.name»
      '''
      fsa.generateFile("./" + model.contractName + "/domain/events/" + event.name + ".js", code)
    } else if (event.regularType !== null) {
      val parentType = event.regularType
      val allAttributes = Helpers.getAttributesOfRegularType(event)
      val parentAttributes = new ArrayList<Attribute>(allAttributes)
      parentAttributes.removeAll(event.attributes)
      val code = '''
        const { «parentType.name» } = require("./«parentType.name».js");
        const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»);
        
        class «event.name» extends «parentType.name» {
          constructor(_name,«allAttributes.map[Attribute a | a.name].join(', ')») {
            super(_name,«parentAttributes.map[Attribute a | a.name].join(', ')»)
            this._type = "«event.name»"
            «FOR attribute : event.attributes»
             «IF (attribute.name !='performer' && attribute.name !='controller')»
                this.«attribute.name» = new Attribute("«attribute.name»",«attribute.name»)
              «ENDIF»
            «ENDFOR»
          }
        }
        
        module.exports.«event.name» = «event.name»
      '''
      fsa.generateFile("./" + model.contractName + "/domain/events/" + event.name + ".js", code)
    }
  }
  
  //
    def void generateRole(IFileSystemAccess2 fsa, Model model, RegularType role) {
    	   val isBase = role.ontologyType !== null
 
    if (isBase === true) {
      val code = '''
        const { Role } = require(«ROLE_CLASS_IMPORT_PATH»);
        const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»);
        
        class «role.name» extends Role {
          constructor(_name,«role.attributes.map[Attribute a | a.name].join(', ')») {
            super()
            this._name = _name
            this._type = "«role.name»"
            «FOR attribute : role.attributes»
                «IF (attribute.name !='controller')»
                this.«attribute.name» = new Attribute("«attribute.name»",«attribute.name»)
                  «ENDIF»
            «ENDFOR»
          }
        }
        
        module.exports.«role.name» = «role.name»
      '''
      fsa.generateFile("./" + model.contractName + "/domain/roles/" + role.name + ".js", code)
    } else if (role.regularType !== null) {
      val parentType = role.regularType
      val allAttributes = Helpers.getAttributesOfRegularType(role)
      val parentAttributes = new ArrayList<Attribute>(allAttributes)
      parentAttributes.removeAll(role.attributes)
      val code = '''
        const { «parentType.name» } = require("./«parentType.name».js");
        const { Attribute } = require(«ATTRIBUTE_CLASS_IMPORT_PATH»);
        
        class «role.name» extends «parentType.name» {
          constructor(_name,«allAttributes.map[Attribute a | a.name].join(', ')») {
            super(_name,«parentAttributes.map[Attribute a | a.name].join(', ')»)
            this._type = "«role.name»"
            «FOR attribute : role.attributes»
             «IF ( attribute.name !='controller')»
             this.«attribute.name» = new Attribute("«attribute.name»",«attribute.name»)
              «ENDIF»
            «ENDFOR»
          }
        }
        
        module.exports.«role.name» = «role.name»
      '''
      fsa.generateFile("./" + model.contractName + "/domain/roles/" + role.name + ".js", code)
    }
  }
  
  //
    def void generateEnumeration(IFileSystemAccess2 fsa, Model model, Enumeration enumeration) {
    val code = '''      
      module.exports.«enumeration.name» = {
        «FOR item : enumeration.enumerationItems»
          «item.name»: «enumeration.enumerationItems.indexOf(item)»,
        «ENDFOR»
      }
    '''
    fsa.generateFile("./" + model.contractName + "/domain/types/" + enumeration.name + ".js", code)
  }
  
  //
def boolean findRole(String e ){
	for (role : roles) {
		if (role.name.equals(e)) return true	
		}
		return false
		}
// if controller come from specification for event.   
def String getDefaultController(Model model, Variable variable){
	var RegularType base = Helpers.getBaseType(variable.type)
        if (base !== null) {
        	 for (assignment: variable.attributes){
                if ( assignment instanceof AssignExpression ) {
                	switch base.ontologyType.name {
 
                        case 'Asset':  (assignment.name == 'owner'? return generateExpressionString(assignment.value, 'this'))
                        case 'Event':(assignment.name == 'performer'? return generateExpressionString(assignment.value, 'this'))                       
          
                      }	
                 
                 }
              }
              switch base.ontologyType.name {
                        case 'Role': return ( "this."+variable.name)
                        
          }
	         
}
 
}
 
def String getDefaultControllerACPolicy(Model model) {
	var acC="["
                        	var cnt=0
                for(  Controller controller : model.acpolicys.getController()){
                  		var Ref contr = controller.getControllerType()
                	if 	(cnt>0)
                		{
                			acC=acC+","
                		}
            		acC=acC+'this.'+(contr as VariableRef).variable
            					  cnt++
            					
            					
          						
         				 }
                       acC=acC+"]"
                       return acC
                       
			}
// Add controller from specification for power and obligation (triggered/unconditional)
def String getSpecifiedControllerObligation(Obligation obl) {	 	
                var  Ref contr = obl.controller
                  		//var Ref contr = controller.getControllerType()
                	if (contr !== null)
            		return'this.obligations.'+obl.name+".addController(this."+(contr as VariableRef).variable+")"
            		else return ""
            		                       
			}
 
def String getSpecifiedControllerPower(Power power){
	var  Ref contr = power.controller
                				
     if (contr !== null)
            return'this.powers.'+power.name+".addController(this."+(contr as VariableRef).variable+")"
     else return ""	
	
}	
def String getSpecifiedRulesUnCond(Rule rule){
		var String addRule=""
 
         var Permission contr = rule.getPermission()
         var Ref rl=rule.getAccessedRole()
         var Ref r2=rule.getController()
          var String rName=""
         
         if (rule.accessedResource instanceof ResourcePower) {
    			val ResourcePower p = rule.accessedResource as ResourcePower
    			val Power power = p.resourcePo as Power
    		 	rName = "this.powers."+power.name
    		 	if (power.trigger === null){
    		 	addRule=addRule+"this.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", "+rName+", this."+(rl as VariableRef).variable+", this."+(r2 as VariableRef).variable+")\n"
    		 	
    		 	}
        }      
			
		 if (rule.accessedResource instanceof ResourceObligation) {
    			val obr = rule.accessedResource as ResourceObligation
    			val obl = obr.resourceOp as Obligation
    		 	rName = "this.obligations."+obl.name
    		 	if (obl.trigger === null){
    		 	addRule=addRule+"this.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", "+rName+", this."+(rl as VariableRef).variable+", this."+(r2 as VariableRef).variable+")\n"
    		 	
    		 	}
        }
		if (rule.accessedResource instanceof ResourceACPolicy) {
    		 	rName = "aCPolicy"
    		 addRule=addRule+"this.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", this."+rName+", this."+(rl as VariableRef).variable+", this."+(r2 as VariableRef).variable+")\n"
        }       
          if (rule.accessedResource instanceof ResourceDot) {
          	System.out.print("resource dot")
          	 val resourceDot = rule.accessedResource as ResourceDot
          	val r = resourceDot.resourceDot
         
          	 rName =generateDotExpressionString(r, "this")
          	 addRule=addRule+"this.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", "+rName+", this."+(rl as VariableRef).variable+", this."+(r2 as VariableRef).variable+")\n"
          	}
         
        if (rule.accessedResource instanceof ResourceOntologyType) {		
    			val resourceOntologyType = rule.accessedResource as ResourceOntologyType
    		 	rName = resourceOntologyType.resourceOn.name
    		 	addRule=addRule+"this.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", this."+rName+", this."+(rl as VariableRef).variable+", this."+(r2 as VariableRef).variable+")\n"
        }
			
				
return addRule
	
}
 
def String getSpecifiedRulesCondPower(Power powerC, Model model){
		var String addRule=""
         for (Rule rule: model.rules) {
         var Permission contr = rule.getPermission()
         var Ref rl=rule.getAccessedRole()
         var Ref r2=rule.getController()
          var String rName=""
         
         if (rule.accessedResource instanceof ResourcePower) {
    			val ResourcePower p = rule.accessedResource as ResourcePower
    			val Power power = p.resourcePo as Power
    		 	rName = "powers."+power.name
    		 	if ((power.trigger !== null) && (powerC.name == power.name)){
    		 	addRule=addRule+"contract.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", contract."+rName+", contract."+(rl as VariableRef).variable+", contract."+(r2 as VariableRef).variable+")\n"
    		 	
    		 	}
        }      
			
		
		}		
return addRule
	
}
 
def String getSpecifiedRulesCondObligation(Obligation oblC, Model model){
		var String addRule=""
         for (Rule rule: model.rules) {
         var Permission contr = rule.getPermission()
         var Ref rl=rule.getAccessedRole()
         var Ref r2=rule.getController()
          var String rName=""
         
			
		 if (rule.accessedResource instanceof ResourceObligation) {
    			val obr = rule.accessedResource as ResourceObligation
    			val obl = obr.resourceOp as Obligation
    		 	rName = "obligations."+obl.name
    		 	if ((obl.trigger !== null) && (oblC.name === obl.name)){
    		 	addRule=addRule+"contract.aCPolicy.addRulee(\""+rule.action.toLowerCase+"\", \""+contr.name.toLowerCase+"\", contract."+rName+", contract."+(rl as VariableRef).variable+", contract."+(r2 as VariableRef).variable+")\n"
    		 	
    		 	}
       }
		}		
return addRule
	
}
 
//
def String compileInitMethod(Model model) {
    val code = '''
      async init(ctx, args) {
      	const inputs = JSON.parse(args);
        const contractInstance = new «model.contractName» («model.parameters.map[Parameter p | "inputs." + p.name].join(', ')»)
        this.initialize(contractInstance)
        if (contractInstance.activated()) {
          // call trigger transitions for legal positions
          «FOR obligation : triggeredObligations»
            «IF obligation.antecedent instanceof PAtomPredicateTrueLiteral»
              contractInstance.obligations.«obligation.name».trigerredUnconditional()
            «ELSE»
              contractInstance.obligations.«obligation.name».trigerredConditional()
            «ENDIF»
          «ENDFOR»
          «FOR obligation : triggeredSurvivingObligations»
            «IF obligation.antecedent instanceof PAtomPredicateTrueLiteral»  
              contractInstance.survivingObligations.«obligation.name».trigerredUnconditional()
            «ELSE»
              contractInstance.survivingObligations.«obligation.name».trigerredConditional()
            «ENDIF»
          «ENDFOR»
          «FOR power : triggeredPowers»
            «IF power.antecedent instanceof PAtomPredicateTrueLiteral»
              contractInstance.powers.«power.name».trigerredUnconditional()
            «ELSE»
              contractInstance.powers.«power.name».trigerredConditional()
            «ENDIF»
          «ENDFOR»
      
          await ctx.stub.putState(contractInstance.id, Buffer.from(serialize(contractInstance)))
      
          return {successful: true, contractId: contractInstance.id}
        } else {
          return {successful: false}
        }
      }
    '''
    return code
  }
  
  // AC: adding access control at Runtime
    def List<String> compileEventTriggerMethods(Model model) {
    val methods = new ArrayList<String>
    for (variable : eventVariables) {
      methods.add('''
        async trigger_«variable.name»(ctx, args) {
        	const inputs = JSON.parse(args);
        	const contractId = inputs.contractId;
        	const event = inputs.event;
          const contractState = await ctx.stub.getState(contractId)
          if (contractState == null) {
            return {successful: false}
          }
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
          if (contract.isInEffect() «survivEvent(variable.name)» ){
          	if(!contract.accessPolicy.hasPermesstion('grant','read', contract.«variable.name», contract.shipper, contract.shipper) || 
          	      !contract.accessPolicy.isValid(new Rule('grant','read', contract.«variable.name», contract.shipper, contract.shipper)) ){
          	        throw new Error(`access denied...`)
          	      }
            contract.«variable.name».happen(event)
            Events.emitEvent(contract, new InternalEvent(InternalEventSource.contractEvent, InternalEventType.contractEvent.Happened, contract.«variable.name»))
            await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
            return {successful: true}
          } else {
            return {successful: false}
          }
        }
      ''')
    }
    return methods
  }
  
 //AC conditions in power consequent
 
  def String compilePowerCondition(PowerFunction powerFunction) {
    var con=""
    
    //  val powerFunction = power.consequent
      switch (powerFunction) {
        PFObligationSuspended: // resourceType:"obligation", resource: "delivery", state:"Fulfilled"}
              con= "resourceType: \'obligation\', resource: \'"+powerFunction.norm.name+"\', state:\'suspension\'"
        PFObligationResumed:  // there is no state called resumed so we used suspension to check if it is still suspended or not
         con= "resourceType: \'obligation\', resource: \'"+powerFunction.norm.name+"\', state:\'suspension\'"
        PFObligationDischarged:
         con= "resourceType: \'obligation\', resource: \'"+powerFunction.norm.name+"\', state:\'discharge\'"
        PFObligationTerminated:
          con= "resourceType: \'obligation\', resource: \'"+powerFunction.norm.name+"\', state:\'unsuccessfultermination\'"
        PFObligationTriggered:
          con= "resourceType: \'obligation\', resource: \'"+powerFunction.norm.name+"\', state:\'create\'"
        PFContractSuspended:
          con= "resourceType: \'contract\', resource: \'contract\', state:\'suspension\'"
        PFContractResumed:  // there is no state called resumed so we used suspension to check if it is still suspended or not
          con= "resourceType: \'contract\', resource: \'contract\', state:\'suspension\'"
        PFContractTerminated:
          con= "resourceType: \'contract\', resource: \'contract\', state:\'unsuccessfultermination\'"
      }
    
    return con
  }
 
  //
  
  def List<String> compilePowerTransactions(Model model) {
    val methods = new ArrayList<String>
    for (power : model.powers) {
      val powerFunction = power.consequent
      switch (powerFunction) {
        PFObligationSuspended:
          methods.add(
            generatePowerTransactionForObligation(power.name, powerFunction.norm.name, 'suspended'))
        PFObligationResumed:
          methods.add(
            generatePowerTransactionForObligation(power.name, powerFunction.norm.name, 'resumed'))
        PFObligationDischarged:
          methods.add(
            generatePowerTransactionForObligation(power.name, powerFunction.norm.name, 'discharged'))
        PFObligationTerminated:
          methods.add(
            generatePowerTransactionForObligation(power.name, powerFunction.norm.name, 'terminated'))
        PFObligationTriggered:
          methods.add(
            generatePowerTransactionForObligation(power.name, powerFunction.norm.name, 'triggered'))
        PFContractSuspended:
          methods.add(generatePowerTransactionForContract(power.name, 'suspended'))
        PFContractResumed:
          methods.add(generatePowerTransactionForContract(power.name, 'resumed'))
        PFContractTerminated:
          methods.add(generatePowerTransactionForContract(power.name, 'terminated'))
      }
    }
    return methods
  }
  //
   def List<String> compileViolationEventsTransactions(Model model) {
    val methods = new ArrayList<String>
 
    for (obligation : allObligations) {
      methods.add('''
        async violateObligation_«obligation.name»(ctx, contractId) {
          const contractState = await ctx.stub.getState(contractId)
          if (contractState == null) {
            return {successful: false}
          }
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
        
          if (contract.isInEffect()) {
            if (contract.obligations.«obligation.name» != null){
            	if(!contract.accessPolicy.hasPermesstion('grant','read', contract.obligations.«obligation.name», contract.buyer, contract.buyer) || 
            	      !contract.accessPolicy.isValid(new Rule('grant','read', contract.obligations.«obligation.name», contract.buyer, contract.buyer)) ){
            	        throw new Error(`access denied...`)
            	      }
            	if (contract.obligations.«obligation.name».violated()) {      
              		await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
              		return {successful: true}
            	} else {
              		return {successful: false}
            	}
            }else {
                        return {successful: false}
                      }
          } else {
            return {successful: false}
          }
        }
      ''')
    }
    // we added | contract.isSuccessfulTermination()
    for (obligation : allSurvivingObligations) {
      methods.add('''
        async violateSurvivingObligations_«obligation.name»(ctx, contractId) {
          const contractState = await ctx.stub.getState(contractId)
          if (contractState == null) {
            return {successful: false}
          }
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
        
          if (contract.isInEffect() || contract.isSuccessfulTermination()) {
            if (contract.survivingObligations.«obligation.name» != null && contract.survivingObligations.«obligation.name».violated()) {      
              await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
              return {successful: true}
            } else {
              return {successful: false}
            }
          } else {
            return {successful: false}
          }
        }
      ''')
    }
    return methods
  }
  
  //
  
  def List<String> compileExpirationTransactions(Model model) {
    val methods = new ArrayList<String>
 
    for (obligation : conditionalObligations) {
      methods.add('''
        async expireObligation_«obligation.name»(ctx, contractId) {
          const contractState = await ctx.stub.getState(contractId)
          if (contractState == null) {
            return {successful: false}
          }
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
        
          if (contract.isInEffect()) {
            if (contract.obligations.«obligation.name» != null){
            	if(!contract.accessPolicy.hasPermesstion('grant','read', contract.obligations.«obligation.name», contract.buyer, contract.buyer) || 
            	    !contract.accessPolicy.isValid(new Rule('grant','read', contract.obligations.«obligation.name», contract.buyer, contract.buyer)) ){
            	          throw new Error(`access denied...`)
            	    }
            	if (contract.obligations.«obligation.name».expired()) {      
             		 await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
              		 return {successful: true}
            	} else {
              		return {successful: false}
           		 }
           } else {
             		return {successful: false}
                    }		 
          } else {
            return {successful: false}
          }
        }
      ''')
    }
    // New, it is added to update the state of the surviving obligations
    for (obligation : conditionalSurvivingObligations) {
      methods.add('''
        async expireSurvivingObligation_«obligation.name»(ctx, contractId) {
          const contractState = await ctx.stub.getState(contractId)
          if (contractState == null) {
            return {successful: false}
          }
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
        
          if (contract.isInEffect() || contract.isSuccessfulTermination()) {
            if (contract.survivingObligations.«obligation.name» != null && contract.survivingObligations.«obligation.name».expired()) {      
              await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
              return {successful: true}
            } else {
              return {successful: false}
            }
          } else {
            return {successful: false}
          }
        }
      ''')
    }
    return methods
  }
 
  def List<String> compilePowerExpirationTransactions(Model model) {
    val methods = new ArrayList<String>
 
    for (power : allPowers) {
      methods.add('''
        async expirePower_«power.name»(ctx, contractId) {
          const contractState = await ctx.stub.getState(contractId)
          if (contractState == null) {
            return {successful: false}
          }
          const contract = deserialize(contractState.toString())
          this.initialize(contract)
        
          if (contract.isInEffect()) {
            if (contract.powers.«power.name» != null){
            	if(!contract.accessPolicy.hasPermesstion('grant','read', contract.powers.«power.name», contract.buyer, contract.buyer) || 
            	    !contract.accessPolicy.isValid(new Rule('grant','read', contract.powers.«power.name», contract.buyer, contract.buyer)) ){
            	           throw new Error(`access denied...`)
            	    } 
            if (contract.powers.«power.name».expired()) {      
              await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
              return {successful: true}
            } else {
              return {successful: false}
            }
            } else {
                          return {successful: false}
                        }
          } else {
            return {successful: false}
          }
        }
      ''')
    }
    return methods
  }
  
 // AC: line 104-1047 are added in the specific place so we can make the comparsion after we are sure it is inEffect not null 
    def String generatePowerTransactionForObligation(String powerName, String obligationName, String stateMethod) {
    return '''
    async p_«powerName»_«stateMethod»_o_«obligationName»(ctx, contractId) {
      const contractState = await ctx.stub.getState(contractId)
      if (contractState == null) {
        return {successful: false}
      }
      const contract = deserialize(contractState.toString())
      this.initialize(contract)
      if (contract.isInEffect() && contract.powers.«powerName» != null && contract.powers.«powerName».isInEffect()) {
        if(!contract.accessPolicy.hasPermesstion('grant','read', contract.powers.«powerName», contract.buyer, contract.buyer) || 
                  !contract.accessPolicy.isValid(new Rule('grant','read', contract.powers.«powerName», contract.buyer, contract.buyer)) ){
                    throw new Error(`access denied...`)
                  }
        «IF stateMethod.equals("triggered")»
        if (contract.powers.«powerName».exerted()) {
        «ELSE»
        const obligation = contract.«isSurvivingObligation(obligationName) ? "survivingObligations" : "obligations"».«obligationName»
        if (obligation != null && obligation.«stateMethod»() && contract.powers.«powerName».exerted()) {
        «ENDIF»
          await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
          return {successful: true}
        } else {
          return {successful: false}
        }
      } else {
        return {successful: false}
      }
    }'''
  }
  
   def String generatePowerTransactionForContract(String powerName, String stateMethod) {
    return '''
    async p_«powerName»_«stateMethod»_contract(ctx, contractId) {
      const contractState = await ctx.stub.getState(contractId)
      if (contractState == null) {
        return {successful: false}
      }
      const contract = deserialize(contractState.toString())
      this.initialize(contract)
    
      if (contract.isInEffect() && contract.powers.«powerName» != null && contract.powers.«powerName».isInEffect()) {
      	if(!contract.accessPolicy.hasPermesstion('grant','read', contract.powers.«powerName», contract.buyer, contract.buyer) || 
      	          !contract.accessPolicy.isValid(new Rule('grant','read', contract.powers.«powerName», contract.buyer, contract.buyer)) ){
      	            throw new Error(`access denied...`)
      	          }
        for (let index in contract.obligations) {
          const obligation = contract.obligations[index]
          «IF stateMethod.equals("suspended")»
          obligation._suspendedByContractSuspension = true
          obligation.suspended()
          «ELSEIF stateMethod.equals("resumed")»
          if (obligation._suspendedByContractSuspension === true){
            obligation.resumed()
          }
          «ELSEIF stateMethod.equals("terminated")»
          obligation.terminated({emitEvent: false})
          «ENDIF»
        }
        for (let index in contract.survivingObligations) {
          const obligation = contract.survivingObligations[index]
          «IF stateMethod.equals("suspended")»
          obligation._suspendedByContractSuspension = true
          obligation.suspended()
          «ELSEIF stateMethod.equals("resumed")»
          if (obligation._suspendedByContractSuspension === true){
            obligation.resumed()
          }
          «ELSEIF stateMethod.equals("terminated")»
          obligation.terminated()
          «ENDIF»
        }
        for (let index in contract.powers) {
          const power = contract.powers[index]
          if (index === '«powerName»') {
            continue;
          }
          «IF stateMethod.equals("suspended")»
          power._suspendedByContractSuspension = true
          power.suspended()
          «ELSEIF stateMethod.equals("resumed")»
          if (power._suspendedByContractSuspension === true){
            power.resumed()
          }
          «ELSEIF stateMethod.equals("terminated")»
          power.terminated()
          «ENDIF»
        }        
        if (contract.«stateMethod»() && contract.powers.«powerName».exerted()) {
          await ctx.stub.putState(contractId, Buffer.from(serialize(contract)))
          return {successful: true}
        } else {
          return {successful: false}
        }
      } else {
        return {successful: false}
      }
    }'''
  }
  
  ///////////////////////////////////////////////////////////////
 
  def void parse(Model model) {
    parameters.addAll(model.parameters)
    variables.addAll(model.variables)
 
    for (domainType : model.domainTypes) {
      if (domainType instanceof RegularType) {
        var RegularType base = Helpers.getBaseType(domainType)
        if (base !== null) {
          switch base.ontologyType.name {
            case 'Asset': assets.add(domainType as RegularType)
            case 'Event': events.add(domainType as RegularType)
            case 'Role': roles.add(domainType as RegularType)
          }
        }
      } else if (domainType instanceof Enumeration) {
        enumerations.add(domainType as Enumeration)
      }
    }
 
    // event variables
    for (variable : model.variables) {
      if (events.indexOf(variable.type) != -1) {
        eventVariables.add(variable)
      }
    }
 
    // filtering conditional and untriggered obligations and powers
    for (obligation : model.obligations) {
      if (obligation.trigger !== null) {
        untriggeredObligations.add(obligation)
      } else {
        triggeredObligations.add(obligation)
      }
      if (obligation.antecedent instanceof PAtomPredicateTrueLiteral) {
        unconditionalObligations.add(obligation)
      } else {
        conditionalObligations.add(obligation)
      }
    }
    for (obligation : model.survivingObligations) {
      if (obligation.trigger !== null) {
        untriggeredSurvivingObligations.add(obligation)
      } else {
        triggeredSurvivingObligations.add(obligation)
      }
      if (obligation.antecedent instanceof PAtomPredicateTrueLiteral) {
        unconditionalSurvivingObligations.add(obligation)
      } else {
        conditionalSurvivingObligations.add(obligation)
      }
    }
    for (power : model.powers) {
      if (power.trigger !== null) {
        untriggeredPowers.add(power)
      } else {
        triggeredPowers.add(power)
      }
      if (power.antecedent instanceof PAtomPredicateTrueLiteral) {
        unconditionalPowers.add(power)
      } else {
        conditionalPowers.add(power)
      }
    }
    
    allObligations.addAll(untriggeredObligations)
    allObligations.addAll(triggeredObligations)
    allSurvivingObligations.addAll(untriggeredSurvivingObligations)
    allSurvivingObligations.addAll(triggeredSurvivingObligations)
    allPowers.addAll(untriggeredPowers)
    allPowers.addAll(triggeredPowers)
 
    // collect trigger events
    for (obligation : untriggeredObligations) {
      val proposition = obligation.trigger
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        obligationTriggerEvents.put(obligation, list)
      }
    }
    for (obligation : untriggeredSurvivingObligations) {
      val proposition = obligation.trigger
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        survivingObligationTriggerEvents.put(obligation, list)
      }
    }
    for (power : untriggeredPowers) {
      val proposition = power.trigger
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        powerTriggerEvents.put(power, list)
      }
    }
    // collect fulfillment events of obligations
    for (obligation : allObligations) {
      val proposition = obligation.consequent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        obligationFullfilmentEvents.put(obligation, list)
      }
    }
    for (obligation : allSurvivingObligations) {
      val proposition = obligation.consequent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        survivingObligationFullfilmentEvents.put(obligation, list)
      }
    }
    // collect antecedent activates
    for (obligation : conditionalObligations) {
      val proposition = obligation.antecedent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        obligationAntecedentEvents.put(obligation, list)
      }
    }
    for (obligation : conditionalSurvivingObligations) {
      val proposition = obligation.antecedent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        survivingObligationAntecedentEvents.put(obligation, list)
      }
    }
    for (power : conditionalPowers) {
      val proposition = power.antecedent
      val list = collectPropositionEvents(proposition)
      if (list.size > 0) {
        powerAntecedentEvents.put(power, list)
      }
    }
 
  }
	
 
def void generateNPMFile(IFileSystemAccess2 fsa, Model model) {
    val file = '''
      {
        "name": "«model.contractName.toLowerCase»",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "engines": {
          "node": ">=14",
          "npm": ">=5"
        },
        "scripts": {
          "lint": "eslint .",
          "pretest": "npm run lint",
          "test": "nyc mocha --recursive",
          "start": "fabric-chaincode-node start"
        },
        "engineStrict": true,
        "author": "Symboleo2SC",
        "dependencies": {
          "fabric-contract-api": "^2.2.2",
          "fabric-shim": "^2.2.2",
          "symboleo-js-core": "^1.0.12"
        },
        "devDependencies": {
          "chai": "^4.1.2",
          "eslint": "^8.7.0",
          "eslint-config-airbnb-base": "^15.0.0",
          "eslint-plugin-import": "^2.25.4",
          "mocha": "^8.0.1",
          "nyc": "^14.1.1",
          "sinon": "^6.0.0",
          "sinon-chai": "^3.2.0"
        }
      }
    '''
    fsa.generateFile("./" + model.contractName + "/package.json", file)
  }
 
  def String compileEventsMap() {
    // trigger events to instantiate
   // val arrays= new ArrayList<String>
    for (obligation : obligationTriggerEvents.keySet) {
      arrays.add(
        generateEventMapLineString(
          obligationTriggerEvents.get(obligation), '''EventListeners.createObligation_«obligation.name»'''))
    }
    for (obligation : survivingObligationTriggerEvents.keySet) {
      arrays.add(
        generateEventMapLineString(survivingObligationTriggerEvents.get(
          obligation), '''EventListeners.createSurvivingObligation_«obligation.name»'''))
    }
    for (power : powerTriggerEvents.keySet) {
      arrays.add(
        generateEventMapLineString(powerTriggerEvents.get(power), '''EventListeners.createPower_«power.name»'''))
    }
 
    // antecedent events to activate
    for (obligation : obligationAntecedentEvents.keySet) {
      arrays.add(
        generateEventMapLineString(
          obligationAntecedentEvents.get(obligation), '''EventListeners.activateObligation_«obligation.name»'''))
    }
    for (obligation : survivingObligationAntecedentEvents.keySet) {
      arrays.add(
        generateEventMapLineString(survivingObligationAntecedentEvents.get(
          obligation), '''EventListeners.activateSurvivingObligation_«obligation.name»'''))
    }
    for (power : powerAntecedentEvents.keySet) {
      arrays.add(
        generateEventMapLineString(powerAntecedentEvents.get(power), '''EventListeners.activatePower_«power.name»'''))
    }
 
    // fulfill obligation events
    for (obligation : obligationFullfilmentEvents.keySet) {
      arrays.add(
        generateEventMapLineString(
          obligationFullfilmentEvents.get(obligation), '''EventListeners.fulfillObligation_«obligation.name»'''))
    }
    for (obligation : survivingObligationFullfilmentEvents.keySet) {
      arrays.add(
        generateEventMapLineString(survivingObligationFullfilmentEvents.get(
          obligation), '''EventListeners.fulfillSurvivingObligation_«obligation.name»'''))
    }
    // contract termination
//    for (obligation : allObligations) {
//      arrays.
//        add('''[[new InternalEvent(InternalEventSource.obligation, InternalEventType.obligation.Fulfilled, contract.obligations.«obligation.name»)], EventListeners.successfullyTerminateContract],''')
//    }
 
    return '''
      function getEventMap(contract) {
        return [
          «FOR line : arrays»
            «line»
          «ENDFOR»
        ]
      }
    '''
  }
 
  
  def void compileSerializerFile(IFileSystemAccess2 fsa, Model model) {
    val code = '''
    //Flat library to solve the circular problem when stringifying node objects
    const {stringify, parse } = require('flatted')
    const { «model.contractName» } = require("./domain/contract/«model.contractName».js")
    const { Obligation, ObligationActiveState, ObligationState } = require(«OBLIGATION_CLASS_IMPORT_PATH»)
    const { InternalEventType, InternalEvent, InternalEventSource} = require(«EVENTS_CLASS_IMPORT_PATH»)
    const { Event } = require(«EVENTS_CLASS_IMPORT_PATH»)
    const { Power } = require(«POWER_CLASS_IMPORT_PATH»)
    const { ACPolicy } = require(«ACPolicy_CLASS_IMPORT_PATH»)
    
    let contract = null
    
    function deserialize(data) {
       let object = parse(data,reviver);
      // to update all the assign variable with the new value. We check the type of the variable before assiging the new value
      contract = new «model.contractName»(«model.parameters.map[Parameter p | "object." + p.name].join(',')»)
      « FOR e : AssignVar »
                  contract.«e»= object.«e»
            «ENDFOR»
    contract.state = object.state
    contract.activeState = object.activeState
      
    // Add roles to role list
    for(obj of object._roles){
      contract.addRole(obj)
    }
    
    // Remove roles that were removed at runtime as initiating the contract genrates the same roles at design time
    let toRemoveRole = []
    for (let i = 0; i < contract._roles.length; i++) {
       let isRole = false
     
       if (contract._roles[i] !== undefined) {
       isRole = object._roles.some(obj => obj._name === contract._roles[i]._name && obj._type === contract._roles[i]._type)
    }
   
    if (!isRole) {
       toRemoveRole.push(contract._roles[i])
      }
    }
 
    contract._roles = contract._roles.filter(
      item => !toRemoveRole.some(
        other => other._name === item._name && other._type === item._type
      )
    );
 
    //AC for genrtaing certificate for each user, use name as an enrollment ID
    contract.userList = object.userList
 
    //AC- acpolicy
    const ac = new ACPolicy()
   
    //ac = object.accessPolicy
    contract.accessPolicy = ac  
 
    //return all objects 
    for (const key of Object.keys(object)) {
   
       if(key !== 'obligations' && key !== 'powers'){
      
         if (typeof object[key] === 'object' && object[key] !== null && !Array.isArray(object[key])) {
         
           for(const eKey of Object.keys(object[key])) {
           	if(typeof  object[key][eKey] === 'object' &&  object[key][eKey] !== null){
           		if(object[key][eKey]._type === 'Attribute'){
              		contract[key][eKey]._value = object[key][eKey]._value
           	  }else{
            	//if it is a list but it is not controller, bring it back
            	const x = object[key][eKey]
            	if(eKey !== '_controller'){
                 	if(contract[object[key][eKey]._name] !=  undefined){ 
                  		if(contract[x._name]._type === x._type){
    
                    		contract[key][eKey] =  contract[x._name]
      
                  		}else{//return objects that does not have type
                    		contract[key][eKey] = object[key][eKey]
                  		}
                                  
                }else{//return objects that does not have name
                	contract[key][eKey] = object[key][eKey]
                }
                
              }
            }
             
            }else{//string/numerical and so on 
              contract[key][eKey] = object[key][eKey]
              }
           }//nested for
         }
       }
    }
     
 
    contract.accessPolicy._rules = object.accessPolicy._rules
    // internal events (violated, suspended, ..)     
      for (const eventType of Object.keys(InternalEventType.contract)) {
        if (object._events[eventType] != null) {
          const eventObject = new Event()
          eventObject._triggered = object._events[eventType]._triggered
          eventObject._timestamp = object._events[eventType]._timestamp
          contract._events[eventType] = eventObject
        }
      }
 
    «FOR obligation : allObligations»
    if (object.obligations.«obligation.name» != null) {
        const obligation = new Obligation('«obligation.name»', «generateDotExpressionString(obligation.creditor, "contract")», «generateDotExpressionString(obligation.debtor, "contract")», contract)
        obligation.state = object.obligations.«obligation.name».state
        obligation.activeState = object.obligations.«obligation.name».activeState
        obligation.consequent = object.obligations.«obligation.name».consequent
        obligation.antecedent = object.obligations.«obligation.name».antecedent
        obligation._createdPowerNames = object.obligations.«obligation.name»._createdPowerNames
        obligation._suspendedByContractSuspension = object.obligations.«obligation.name»._suspendedByContractSuspension
        for (const eventType of Object.keys(InternalEventType.obligation)) {
          if (object.obligations.«obligation.name»._events[eventType] != null) {
            const eventObject = new Event()
            eventObject._triggered = object.obligations.«obligation.name»._events[eventType]._triggered
            eventObject._timestamp = object.obligations.«obligation.name»._events[eventType]._timestamp
            obligation._events[eventType] = eventObject
          }
        }
        contract.obligations.«obligation.name» = obligation
    }
    «ENDFOR»
    
      «FOR obligation : allSurvivingObligations»
      if (object.survivingObligations.«obligation.name» != null) {
        const obligation = new Obligation('«obligation.name»', «generateDotExpressionString(obligation.creditor, "contract")», «generateDotExpressionString(obligation.debtor, "contract")», contract, true)
        obligation.state = object.survivingObligations.«obligation.name».state
        obligation.activeState = object.survivingObligations.«obligation.name».activeState
        obligation._createdPowerNames = object.survivingObligations.«obligation.name»._createdPowerNames
        obligation._suspendedByContractSuspension = object.survivingObligations.«obligation.name»._suspendedByContractSuspension
        for (const eventType of Object.keys(InternalEventType.obligation)) {
          if (object.survivingObligations.«obligation.name»._events[eventType] != null) {
            const eventObject = new Event()
            eventObject._triggered = object.survivingObligations.«obligation.name»._events[eventType]._triggered
            eventObject._timestamp = object.survivingObligations.«obligation.name»._events[eventType]._timestamp
            obligation._events[eventType] = eventObject
          }
        }
        contract.survivingObligations.«obligation.name» = obligation
      }
      «ENDFOR»
      
      «FOR power : allPowers»
      if (object.powers.«power.name» != null) {
        const power = new Power('«power.name»', «generateDotExpressionString(power.creditor, "contract")», «generateDotExpressionString(power.creditor, "contract")», contract)
        power.state = object.powers.«power.name».state
        power.activeState = object.powers.«power.name».activeState
        power.consequent = object.powers.«power.name».consequent
        power.antecedent = object.powers.«power.name».antecedent
        for (const eventType of Object.keys(InternalEventType.power)) {
          if (object.powers.«power.name»._events[eventType] != null) {
            const eventObject = new Event()
            eventObject._triggered = object.powers.«power.name»._events[eventType]._triggered
            eventObject._timestamp = object.powers.«power.name»._events[eventType]._timestamp
            power._events[eventType] = eventObject
          }
        }
        contract.powers.«power.name» = power
      }
      «ENDFOR»
    const contractList=[«variables.map[Variable v | "'" + v.name + "'"].join(',')»,'accessPolicy']  
    for (const key of contractList) {
                if(object[key] === 'undefined'){
                   continue
                  }else{
            
                    contract[key]._controller = []
                    for(const valuet of object[key]._controller) {
                      contract[key].addController(reviverList(valuet)) 
                 
                    }//for Event
                    if(contract[key] instanceof Event){
                      contract[key]._performer = []
                      for(const valuet of object[key]._performer) {
                      	contract[key].addPerformer(reviverList(valuet)) 
                      }
            
                    }
                     //retrive and add controller to attributes 
                     
                     for (const eKey of Object.keys(object[key])) { 
                           let attr = object[key][eKey]
                           if(typeof attr === 'object' && attr !== null){
                           if(attr._type === 'Attribute'){
                             contract[key][eKey]._controller = []
                              for(const valuet of object[key][eKey]._controller) {
                              contract[key][eKey].addController(reviverList(valuet)) 
                            }
                          }
            
                          }
            
                  }
            
                  }
          }  
   //retrive all obligation and add controllers, performers and so on
   for (const key of Object.keys(contract.obligations)){
           contract.obligations[key]._controller = []
           for(const valuet of object.obligations[key]._controller) {
             contract.obligations[key].addController(reviverList(valuet)) 
            }
             contract.obligations[key]._performer = []
             for(const valuet of object.obligations[key]._performer) {
               contract.obligations[key].addPerformer(reviverList(valuet)) 
             }
             
             contract.obligations[key]._rightHolder = []
             for(const valuet of object.obligations[key]._rightHolder) {
               contract.obligations[key].addRightHolder(reviverList(valuet)) 
             }
   
             contract.obligations[key]._liable = []
             for(const valuet of object.obligations[key]._liable) {
               contract.obligations[key].addLiable(reviverList(valuet)) 
             }
   
       
   }
   //power
   //retrive all power and add controllers, performers and so on
   for (const key of Object.keys(contract.powers)){
     contract.powers[key]._controller = []
     for(const valuet of object.powers[key]._controller) {
       contract.powers[key].addController(reviverList(valuet)) 
     }
       contract.powers[key]._performer = []
       for(const valuet of object.powers[key]._performer) {
         contract.powers[key].addPerformer(reviverList(valuet)) 
       }
       
       contract.powers[key]._rightHolder = []
       for(const valuet of object.powers[key]._rightHolder) {
         contract.powers[key].addRightHolder(reviverList(valuet)) 
       }
   
       contract.powers[key]._liable = []
       for(const valuet of object.powers[key]._liable) {
         contract.powers[key].addLiable(reviverList(valuet)) 
       }
   
   }
   
      //add controller to contract 
      contract._controller = []
      for(obj of object._controller){
       contract.addController(reviverList(obj)) 
     }
   
     //retrive all rules of all resourcers 
     contract.accessPolicy._rules = []
       for (let i = 0; i < object.accessPolicy._rules.length; i++) {
        
       let obj = object.accessPolicy._rules[i].accessedResource
       let accessedResource = obj
           //retrive rules of obligation and power
       if(object.accessPolicy._rules[i].accessedResource._type.toLowerCase() === 'obligation' || object.accessPolicy._rules[i].accessedResource._type.toLowerCase() === 'power'){
          accessedResource = contract.findLegalPosition(obj.name, obj._type, contract)
       }else{//worked and retrive rules for all resources acccept resources.attribute is in the else
           if(contract[obj._name] != undefined){
            accessedResource = contract[obj._name]
         }else{
            accessedResource = contract[obj._parent][obj._name]
          
         }
       }
       //retrive accessedRole
       obj = object.accessPolicy._rules[i].accessedRole
       let accessedRole=obj
       if(obj != undefined){
          accessedRole = reviverList(obj)
       }
       //retrive byRole
       obj = object.accessPolicy._rules[i].byRole
       let byRole =  obj
       if(obj != undefined){
         byRole =  reviverList(obj)
       }
   
         contract.accessPolicy.addRulee(object.accessPolicy._rules[i].decision,object.accessPolicy._rules[i].permission, accessedResource, accessedRole, byRole)//worked, added to rules
     }
    
      
      return contract
    }
    // to stringify the contract
    function replacer(key, value) {   
      if (value === undefined) {     
         return "<undefined>";   }   
       return value;
     }
    // return roles' objects from contract that are equavelent to the roles' objects in the object after parsing contract data (let object = parse(data,reviver)) 
    function reviverList(aController) {  
  
    if(aController._name !== undefined && aController._name !== 'undefined' && aController !== null  &&  aController !== undefined){
      return contract.getRole(aController._name, aController._type)
    }else{
      return null
    }
    
  }
    // used in pars function to unify the undefined values  
    function reviver(key, value) {   
      if (value === "<undefined>") {     
        return undefined;   
      }
         return value; 
        }
  
  function serialize(contract) {
    for (const key of Object.keys(contract.obligations)){
      contract.obligations[key].contract = undefined
    }
  
    for (const key of Object.keys(contract.powers)){
      contract.powers[key].contract = undefined
    }
  
    for (const key of Object.keys(contract.survivingObligations)){
      contract.survivingObligations[key].contract = undefined
    }
   
    return stringify(contract, replacer, 2); // instead of stringify(contract, null, 2) to solve circular issue when pars the contract
   
  }
  
  module.exports.deserialize = deserialize
  module.exports.serialize = serialize
    '''
    
    fsa.generateFile("./" + model.contractName + "/" + "serializer.js", code)
  }
 
  def void compileEventsFile(IFileSystemAccess2 fsa, Model model) {
 
    val code = '''
      const { LegalSituation, InternalEventSource, InternalEvent, InternalEventType } = require(«EVENTS_CLASS_IMPORT_PATH»)
      const { Obligation } = require(«OBLIGATION_CLASS_IMPORT_PATH»)
      const { Power } = require(«POWER_CLASS_IMPORT_PATH»)
      const { Predicates } = require(«PREDICATES_CLASS_IMPORT_PATH»)
      const { Utils } = require(«UTILS_CLASS_IMPORT_PATH»)
      const { Str } = require(«UTILS_CLASS_IMPORT_PATH»)
      «FOR enumeration : enumerations»
      const { «enumeration.name» } = require("./domain/types/«enumeration.name».js")
      «ENDFOR»
      const { ACPolicy } = require(«ACPolicy_CLASS_IMPORT_PATH»)
      const { Resource } = require(«Resource_CLASS_IMPORT_PATH»)
      
      const EventListeners = {
        «FOR obligation : obligationTriggerEvents.keySet»
          createObligation_«obligation.name»(contract) {
            if («generatePropositionString(obligation.trigger)») { «"\n"+generatePropositionAssignString(obligation.trigger)»
              if (contract.obligations.«obligation.name» == null || contract.obligations.«obligation.name».isFinished()) {
                const isNewInstance =  contract.obligations.«obligation.name» != null && contract.obligations.«obligation.name».isFinished()
                contract.«obligation.name»Situation = new LegalSituation();
            	«IF !(obligation.consequent instanceof PAtomPredicateTrueLiteral)»
                «generateLegalpositionCondition(obligation.consequent,"contract."+obligation.name+"Situation.addConsequentOf(")» 
                «ENDIF»
                «IF !(obligation.antecedent instanceof PAtomPredicateTrueLiteral)»
                 «generateLegalpositionCondition(obligation.antecedent,"contract."+obligation.name+"Situation.addAntecedentOf(")» 
                «ENDIF»
                 contract.obligations.«obligation.name» = new Obligation('«obligation.name»', «generateDotExpressionString(obligation.creditor, 'contract')», «generateDotExpressionString(obligation.debtor, 'contract')», contract, contract.«obligation.name»Situation)
                 «getSpecifiedControllerObligation(obligation)»
                 «getSpecifiedRulesCondObligation(obligation, model)»
                if («obligation.antecedent instanceof PAtomPredicateTrueLiteral ? "true" : "!isNewInstance "» ) { «"\n"+generatePropositionAssignString(obligation.antecedent)»
                  contract.obligations.«obligation.name».trigerredUnconditional()
                  if (!isNewInstance && «generatePropositionString(obligation.consequent)») { «"\n"+generatePropositionAssignString(obligation.consequent)»
                    contract.obligations.«obligation.name».fulfilled()
                  }
                } else {
                  contract.obligations.«obligation.name».trigerredConditional()
                }
              }
            }
          },
        «ENDFOR»
        «FOR obligation : survivingObligationTriggerEvents.keySet»
          createSurvivingObligation_«obligation.name»(contract) {
            if («generatePropositionString(obligation.trigger)») { «"\n"+generatePropositionAssignString(obligation.trigger)»
              if (contract.survivingObligations.«obligation.name» == null || contract.survivingObligations.«obligation.name».isFinished()) {
                contract.survivingObligations.«obligation.name» = new Obligation('«obligation.name»', «generateDotExpressionString(obligation.creditor, 'contract')», «generateDotExpressionString(obligation.debtor, 'contract')», contract, true)
                 «getSpecifiedControllerObligation(obligation)»
                 «getSpecifiedRulesCondObligation(obligation, model)»
                if («generatePropositionString(obligation.antecedent)») { «"\n"+generatePropositionAssignString(obligation.antecedent)»
                  contract.survivingObligations.«obligation.name».trigerredUnconditional()
                  «obligation.consequent instanceof PAtomPredicate ? "" : " if ( !isNewInstance &&" + generatePropositionString(obligation.antecedent)+")" »
                  if («generatePropositionString(obligation.consequent)» ) { «"\n"+generatePropositionAssignString(obligation.consequent)»
                    contract.survivingObligations.«obligation.name».fulfilled()
                  }
                } else {
                  contract.survivingObligations.«obligation.name».trigerredConditional()
                }
              }
            }
          },
        «ENDFOR»
        «FOR power : powerTriggerEvents.keySet»
          createPower_«power.name»(contract) {
            const effects = { powerCreated: false }
            if («generatePropositionString(power.trigger)») { «"\n"+generatePropositionAssignString(power.trigger)»
              if (contract.powers.«power.name» == null || contract.powers.«power.name».isFinished()){
                const isNewInstance =  contract.powers.«power.name» != null && contract.powers.«power.name».isFinished()
                contract.«power.name»Situation = new LegalSituation();            
                           «IF !(power.antecedent instanceof PAtomPredicateTrueLiteral)»
                «generateLegalpositionCondition(power.antecedent,"contract."+power.name+"Situation.addAntecedentOf(")» 
                           «ENDIF»
                            	this.«power.name»Situation.addConsequentOf({_type: 'stateCondition',«compilePowerCondition(power.consequent)»})
                contract.powers.«power.name» = new Power('«power.name»', «generateDotExpressionString(power.creditor, 'contract')», «generateDotExpressionString(power.debtor, 'contract')», contract, contract.«power.name»Situation)
                effects.powerCreated = true
                effects.powerName = '«power.name»'
                «getSpecifiedControllerPower(power)»
                «getSpecifiedRulesCondPower(power, model)»
                if («power.antecedent instanceof PAtomPredicateTrueLiteral ? "true" : "!isNewInstance && "+generatePropositionString(power.antecedent) » ) { «"\n"+generatePropositionAssignString(power.antecedent)»
                  contract.powers.«power.name».trigerredUnconditional()
                } else {
                  contract.powers.«power.name».trigerredConditional()
                }
              }
            }
            return effects
          },
        «ENDFOR»
        «FOR obligation : obligationAntecedentEvents.keySet»
          activateObligation_«obligation.name»(contract) {
            if (contract.obligations.«obligation.name» != null && («generatePropositionString(obligation.antecedent)»)) { «"\n"+generatePropositionAssignString(obligation.antecedent)»
              contract.obligations.«obligation.name».activated()
                            if («generatePropositionString(obligation.consequent)») { «"\n"+generatePropositionAssignString(obligation.consequent)»
                              contract.obligations.«obligation.name».fulfilled()
                            }
                          }
                        },
                      «ENDFOR»
                      «FOR obligation : survivingObligationAntecedentEvents.keySet»
                        activateSurvivingObligation_«obligation.name»(contract) {
                          if (contract.survivingObligations.«obligation.name» != null  && («generatePropositionString(obligation.antecedent)»)  ) { «"\n"+generatePropositionAssignString(obligation.antecedent)»
                            contract.survivingObligations.«obligation.name».activated()
                            if («generatePropositionString(obligation.consequent)») { «"\n"+generatePropositionAssignString(obligation.consequent)»
                              contract.survivingObligations.«obligation.name».fulfilled()
                            }
                          }
                        },
                      «ENDFOR»
                      «FOR power : powerAntecedentEvents.keySet»
                        activatePower_«power.name»(contract) {
                          if (contract.powers.«power.name» != null && («generatePropositionString(power.antecedent)»)) {  «"\n"+generatePropositionAssignString(power.antecedent)»
                            contract.powers.«power.name».activated()
                          }
                        },
                      «ENDFOR»
                      «FOR obligation : obligationFullfilmentEvents.keySet»
                        fulfillObligation_«obligation.name»(contract) {
                          if (contract.obligations.«obligation.name» != null && («generatePropositionString(obligation.consequent)») ) { «"\n"+generatePropositionAssignString(obligation.consequent)»
                            contract.obligations.«obligation.name».fulfilled()
                          }
                        },
                      «ENDFOR»
                      «FOR obligation : survivingObligationFullfilmentEvents.keySet»
                        fulfillSurvivingObligation_«obligation.name»(contract) {
                          if (contract.survivingObligations.«obligation.name» != null && «generatePropositionString(obligation.consequent)» ) { «"\n"+generatePropositionAssignString(obligation.consequent)»
                            contract.survivingObligations.«obligation.name».fulfilled()
                          }
                        },
                      «ENDFOR»
                      successfullyTerminateContract(contract) {
                        for (const oblKey of Object.keys(contract.obligations)) {
                          if (contract.obligations[oblKey].isActive()) {
                            return;
                          }
                          if (contract.obligations[oblKey].isViolated() && Array.isArray(contract.obligations[oblKey]._createdPowerNames)) {
                            for (const pKey of contract.obligations[oblKey]._createdPowerNames) {
                              if (!contract.powers[pKey].isSuccessfulTermination()) {
                                return;
                              }
                            }
                          }
                        }
                        contract.fulfilledActiveObligations()
                      },
                      unsuccessfullyTerminateContract(contract) {
                        for (let index in contract.obligations) {
                          contract.obligations[index].terminated({emitEvent: false})
                        }
                        for (let index in contract.powers) {
                          contract.powers[index].terminated()
                        }
                        contract.terminated()
                      }     
                    }
                    
                    «compileEventsMap()»
                    
                    module.exports.EventListeners = EventListeners
                    module.exports.getEventMap = getEventMap
                  '''
               
                  fsa.generateFile("./" + model.contractName + "/" + "events.js", code)
                }
               
                
                 override def String generateExpressionString(Expression argExpression, String thisString) {
                  switch (argExpression) {
                    Or:
                      return generateExpressionString(argExpression.left, thisString) + " || " +
                        generateExpressionString(argExpression.right, thisString)
                    And:
                      return generateExpressionString(argExpression.left, thisString) + " && " +
                        generateExpressionString(argExpression.right, thisString)
                    Equality:
                      return generateExpressionString(argExpression.left, thisString) + getEqualityOperator(argExpression.op) +
                        generateExpressionString(argExpression.right, thisString)
                    Comparison:
                      return generateExpressionString(argExpression.left, thisString) + argExpression.op +
                        generateExpressionString(argExpression.right, thisString)
                    Plus:
                      return generateExpressionString(argExpression.left, thisString) + " + " +
                        generateExpressionString(argExpression.right, thisString)
                    Minus:
                      return generateExpressionString(argExpression.left, thisString) + " - " +
                        generateExpressionString(argExpression.right, thisString)
                    Multi:
                      return generateExpressionString(argExpression.left, thisString) + " * " +
                        generateExpressionString(argExpression.right, thisString)
                    Div:
                      return generateExpressionString(argExpression.left, thisString) + " / " +
                        generateExpressionString(argExpression.right, thisString)
                    Mod:
                      return generateExpressionString(argExpression.left, thisString) + " % " +
                        generateExpressionString(argExpression.right, thisString)
                    PrimaryExpressionRecursive:
                      return "(" + generateExpressionString(argExpression.inner, thisString) + ")"
                    PrimaryExpressionFunctionCall:
                      return generateFunctionCall(argExpression, thisString)
                    NegatedPrimaryExpression:
                      return "!(" + generateExpressionString(argExpression.expression, thisString) + ")"
                    AtomicExpressionTrue:
                      return "true"
                    AtomicExpressionFalse:
                      return "false"
                    AtomicExpressionDouble:
                      return argExpression.value.toString()
                    AtomicExpressionInt:
                      return argExpression.value.toString()
                    AtomicExpressionDate:
                      return '''(new Date("«argExpression.value.toInstant.toString»").toISOString())'''
                    AtomicExpressionEnum:
                      return argExpression.enumeration + "." + argExpression.enumItem
                    AtomicExpressionString:
                      return '"' + argExpression.value + '"'
                    AtomicExpressionParameter:
                      return generateDotExpressionString(argExpression.value, thisString)
                     
                  }
                }
                override def String generateFunctionCall(PrimaryExpressionFunctionCall argFunctionCallExp, String thisString) {
                  val functionCall = argFunctionCallExp.function
                  switch (functionCall) {
                    TwoArgMathFunction:
                      return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
                        generateExpressionString(functionCall.arg2, thisString) + ")"
                    OneArgMathFunction:
                      return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
                    ThreeArgStringFunction:
                      return functionCall.name.replace("String", "Str") + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
                        generateExpressionString(functionCall.arg2, thisString) + "," + generateExpressionString(functionCall.arg3, thisString) + ")"
                    TwoArgStringFunction:
                      return functionCall.name.replace("String", "Str") + "(" + generateExpressionString(functionCall.arg1, thisString) + "," +
                        generateExpressionString(functionCall.arg2, thisString) + ")"
                    OneArgStringFunction:
                      return functionCall.name.replace("String", "Str") + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
                    ThreeArgDateFunction:
                      return '''Utils.addTime(«generateExpressionString(functionCall.arg1, thisString)», «generateExpressionString(functionCall.value, thisString)», "«functionCall.timeUnit»")'''
                //  TwoArgUserFunction:
                 //     return functionCall.name + "(" + functionCall.arg1.toString() + "," +
                  //      functionCall.arg2.toString() + ")"
                  }
                  
                }
                
                
               
              /* compileDomainTypes*/
               
               
               
               
               
                
                 def String generatePropositionString(Proposition proposition) {
                  switch (proposition) {
                    POr:
                      return generatePropositionString(proposition.left) + "||" + generatePropositionString(proposition.right)
                    PAnd:
                      return generatePropositionString(proposition.left) + "&&" + generatePropositionString(proposition.right)
                    PEquality:
                      return generatePropositionString(proposition.left) + getEqualityOperator(proposition.op) +
                        generatePropositionString(proposition.right)
                    PComparison:
                       return generatePropositionString(proposition.left) + ' ' + proposition.op + ' ' +
                        generatePropositionString(proposition.right)
                    PArithmetic:
                       return generatePropositionString(proposition.left) + ' ' + proposition.op + ' ' +
                        generatePropositionString(proposition.right)
                    PAtomRecursive:
                      return "(" + generatePropositionString(proposition.inner) + ")"
                    NegatedPAtom:
                      return "!(" + generatePropositionString(proposition.negated) + ")"
                    PAtomPredicate:
                      return generatePredicateFunctionString(proposition.predicateFunction)
                    PAtomEnum:
                      return proposition.enumeration.name + "." + proposition.enumItem.name
                    PAtomVariable:
                      return generateDotExpressionString(proposition.variable, 'contract')
                    PAtomPredicateTrueLiteral:
                      return "true"
                    PAtomPredicateFalseLiteral:
                      return "false"
                    PAtomDoubleLiteral:
                      return proposition.value.toString
                    PAtomIntLiteral:
                      return proposition.value.toString
                    PAtomDateLiteral:
                      return '''(new Date("«proposition.value.toInstant.toString»").toISOString())'''
                    PAtomStringLiteral:
                      return proposition.value
                  }
                }
               //AC to return different types of conditions of  antecedents and consequents
                  def String generateLegalpositionCondition(Proposition proposition, String addAC) {
                  switch (proposition) {
                    POr:
                      return generateLegalpositionCondition(proposition.left, addAC) + " " + generateLegalpositionCondition(proposition.right, addAC)
                    PAnd:
                      return generateLegalpositionCondition(proposition.left, addAC) + " " + generateLegalpositionCondition(proposition.right, addAC)
                    PEquality:
                      return  addAC+'{ leftSide:\''+generateLegalpositionCondition(proposition.left, addAC) + '\', op:\''+getEqualityOperator(proposition.op) +
                        '\', rightSide: \''+ generateLegalpositionCondition(proposition.right, addAC)+"\', _type: \'Condition\'})\n"
                    PComparison:
                       return  addAC+'{ leftSide:\''+generateLegalpositionCondition(proposition.left, addAC) + '\', op:\'' + proposition.op + '\', ' +
                        ' rightSide: \''+ generateLegalpositionCondition(proposition.right, addAC)+"\', _type: \'Condition\'}) \n"
                    PArithmetic:
                       return addAC+'{ leftSide:\''+generateLegalpositionCondition(proposition.left, addAC) + '\', op:\''+proposition.op + '\',  ' +
                        ' rightSide: \''+ generateLegalpositionCondition(proposition.right, addAC)+"\', _type: \'Condition\'})\n"
                    PAtomRecursive:
                      return "(" + generateLegalpositionCondition(proposition.inner, addAC) + ")"
                    NegatedPAtom:
                      return "!(" + generateLegalpositionCondition(proposition.negated, addAC) + ")"
                    PAtomPredicate:
                      return "\n"+addAC+generatePredicateFunctionCondition(proposition.predicateFunction)+")\n"
                    PAtomEnum:
                      return proposition.enumeration.name + "." + proposition.enumItem.name
                    PAtomVariable:
                      return generateDotExpressionString(proposition.variable, 'this')
                    PAtomPredicateTrueLiteral:
                      return "true"
                    PAtomPredicateFalseLiteral:
                      return "false"
                    PAtomDoubleLiteral:
                      return proposition.value.toString
                    PAtomIntLiteral:
                      return proposition.value.toString
                    PAtomDateLiteral:
                      return '''(new Date("«proposition.value.toInstant.toString»").toISOString())'''
                    PAtomStringLiteral:
                      return proposition.value
                  }
                }             
               
 //AC
 def String generatePredicateFunctionCondition(PredicateFunction predicate) {
 
    switch (predicate) {
 
      PredicateFunctionHappens: return '''«generateEventVariableCondition(predicate.event)» '''
 
      PredicateFunctionHappensAfter: return '''«generateEventVariableCondition(predicate.event)»'''
 
      PredicateFunctionWHappensBefore: return '''«generateEventVariableCondition(predicate.event)» '''
 
      PredicateFunctionSHappensBefore: return '''«generateEventVariableCondition(predicate.event)»'''
 
      PredicateFunctionHappensWithin: return '''«generateEventVariableCondition(predicate.event)» '''
 
      PredicateFunctionAssignment: return '''«generateEventVariableCondition(predicate.event)» '''
 
       PredicateFunctionAssignmentOnly: return '''true'''
 
    }
 
  }
    // this.paymentLegalSituation.addAntecedentOf({state: "fulfillment", _type: 'stateCondition', resource:"delivery", resourceType:"obligation"})
    //this.deliveryLegalSituation.addAntecedentOf({_type: 'eventCondition', resource:"delivered", resourceType:"Delivered"})           
def String generateEventVariableCondition(Event event) {
    switch (event) {
      VariableEvent: return "{_type: \'eventCondition\', resource:\""+ generateDotExpressionString(event.variable, '')+"\", resourceType:\""+ generateDotExpressionType(event.variable) +"\"}"
      PowerEvent: return '''{{_type: 'stateCondition', resourceType:"power", resource:"«event.powerVariable.name»", state: "«event.eventName»"}'''
      ObligationEvent: return ''' {_type: 'stateCondition', resourceType:"«isSurvivingObligation(event.obligationVariable.name) ? "survivingObligation" : "obligation"»", resource: "«event.obligationVariable.name»", state:"«geteventName(event.eventName)»"}'''
      //ContractEvent: return '''«event.eventName» '''
    }
  }
  def String geteventName(String eventName){
  	 var st=""
  	 switch (eventName.toString) {
  	 	case "Triggered": st='create' 
  	 	case 'Discharged': st= 'discharge' 
  	 	case 'Activated': st= 'active'   //'': st= 'inEffect' 
  	 	case 'Suspended' : st= 'suspension' 
  	 	case 'Resumed': st= 'suspension' 
  	 	case 'Violated': st= 'violation' 
  	 	case 'Fulfilled': st= 'fulfillment' 
  	 	case 'Terminated': st='unsuccessfultermination'   //ContractEvent: return '''«event.eventName» '''
    }
  	return st
  }
//AC to rerieve the type of the event
 def  String  generateDotExpressionType(Ref argRef) {
   var ids = ""
    var ref = argRef
    
    if (ref instanceof VariableRef) {
      for (v : eventVariables) {
      	if ( (ref as VariableRef).variable == v.name) { ids= v.type.name}
      //System.out.print("eventVariables%%%"+v.name+ v.type.name)}
    }
    }
    return ids
  }               
  override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
                  for (e : resource.allContents.toIterable.filter(Model)) {
                    assets.clear()
                    events.clear()
                    roles.clear()
                    enumerations.clear()
                    parameters.clear()
                    
                    arrays.clear()
                    
                    conditionalObligations.clear()
                    conditionalSurvivingObligations.clear()
                    conditionalPowers.clear()
                                                            
                    unconditionalObligations.clear()
                    unconditionalSurvivingObligations.clear()
                    unconditionalPowers.clear()
                 
                    untriggeredObligations.clear()
                    untriggeredSurvivingObligations.clear()
                    untriggeredPowers.clear()
                    
                    
                    triggeredObligations.clear()
                    triggeredSurvivingObligations.clear()
                    triggeredPowers.clear()
                    
                    allObligations.clear()
                    allSurvivingObligations.clear()
                    allPowers.clear()
               
                    eventVariables.clear()
                   
                    
               
                    obligationTriggerEvents.clear()
                    survivingObligationTriggerEvents.clear()
                    powerTriggerEvents.clear()
               
                    obligationAntecedentEvents.clear()
                    survivingObligationAntecedentEvents.clear()
                    powerAntecedentEvents.clear()
               
                    obligationFullfilmentEvents.clear()
                    survivingObligationFullfilmentEvents.clear()
              	
              	  System.out.println('generate2SCSource: ' + e.contractName)
                    var symboleo2SC = new Symboleo2SC()
                    System.out.println('generateHFSource: ' + e.contractName)
                    symboleo2SC.generateHFSource(fsa, e)
                    
                    System.out.println('generatePCSource: ' + e.contractName)
                    var symboleoPC = new SymboleoPCGenerator()
                    symboleoPC.generatePCSource(fsa, e)
                    
                   
                  }
                }
                override void afterGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
                  assets.clear()
                  events.clear()
                  roles.clear()
                  enumerations.clear()
                  parameters.clear()
                  
                  conditionalObligations.clear()
                  conditionalSurvivingObligations.clear()
                  conditionalPowers.clear()
                                                            
                  unconditionalObligations.clear()
                  unconditionalSurvivingObligations.clear()
                  unconditionalPowers.clear()
                                                            
                  untriggeredObligations.clear()
                  untriggeredSurvivingObligations.clear()
                  untriggeredPowers.clear()
               
                  triggeredObligations.clear()
                  triggeredSurvivingObligations.clear()
                  triggeredPowers.clear()
                  
                  allObligations.clear()
                  allSurvivingObligations.clear()
                  allPowers.clear()
               
                  eventVariables.clear()
                  AssignVar.clear()
               
                  obligationTriggerEvents.clear()
                  survivingObligationTriggerEvents.clear()
                  powerTriggerEvents.clear()
               
                  obligationAntecedentEvents.clear()
                  survivingObligationAntecedentEvents.clear()
                  powerAntecedentEvents.clear()
               
                  obligationFullfilmentEvents.clear()
                  survivingObligationFullfilmentEvents.clear()
                }
              
              } 
   