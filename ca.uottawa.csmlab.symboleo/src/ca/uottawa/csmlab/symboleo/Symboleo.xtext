grammar ca.uottawa.csmlab.symboleo.Symboleo with org.eclipse.xtext.common.Terminals

generate symboleo "http://www.uottawa.ca/csmlab/symboleo/Symboleo"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	'Domain' domainName=ID
	(domainTypes+=DomainType ';')+
	'endDomain'
	('TimeGranularity' 'is' timeUnits=TimeUnit)?
	'Contract' contractName=ID '(' (parameters+=Parameter ',')+ (parameters+=Parameter) ')'
	('Declarations' (variables+=Variable ';')*)?
	('Preconditions' (preconditions+=Proposition ';')*)?
	('Postconditions' (postconditions+=Proposition ';')*)?
	('Obligations' (obligations+=Obligation ';')*)+
	('Surviving' 'Obligations' (survivingObligations+=Obligation ';')*)?
	('Powers' (powers+=Power ';')*)?
	('ACPolicy'  acpolicys=ACPolicy (rules+=Rule ';')*)? //AC
	('Constraints' (constraints+=Proposition ';')*)?
	'endContract';

DomainType:
	Alias | RegularType | Enumeration;

Alias:
	name=ID 'isA' type=BaseType;

Enumeration:
	name=ID 'isAn' 'Enumeration' '(' (enumerationItems+=EnumItem ',')* (enumerationItems+=EnumItem) ')';

EnumItem:
	name=ID;

// TODO not extend itself, prevent cycles
//AC-- here I added operation
//AC-- Added if a Role is a contracting party as well
/*
RegularType:
	name=ID ('isA' | 'isAn') ontologyType=OntologyType (thirdParty=ThirdParty)? ('with' (attributes+=Attribute ',')* (attributes+=Attribute))? ('Operation' '('operations+=Operation ',')* (operations+=Operation)')'? |
	name=ID ('isA' | 'isAn') regularType=[RegularType] ('with' (attributes+=Attribute ',')* (attributes+=Attribute))? ('Operation' '('operations+=Operation ',')* (operations+=Operation)')'? |
	name=ID ('isA' | 'isAn') aResource=AResource  ('with' (attributes+=Attribute ',')* (attributes+=Attribute))? ('Operation' '('operations+=Operation ',')* (operations+=Operation)')'?;
*/
RegularType:
	name=ID ('isA' | 'isAn') ontologyType=OntologyType (thirdParty=ThirdParty)? ('with' (attributes+=Attribute ',')* (attributes+=Attribute))? |
	name=ID ('isA' | 'isAn') regularType=[RegularType] ('with' (attributes+=Attribute ',')* (attributes+=Attribute))? |
	name=ID ('isA' | 'isAn') aResource=AResource  ('with' (attributes+=Attribute ',')* (attributes+=Attribute))?
	;

Attribute:
	attributeModifier=AttributeModifier? name=ID ':' baseType=BaseType |
	attributeModifier=AttributeModifier? name=ID ':' domainType=[DomainType];


//AC - user added/defined operation
//Operation:
	//name=ID  ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' ':' baseType=BaseType) |
	//('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' ':' domainType=[DomainType])
//;

//AC
Operation:
   name=ID  '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')'
   ':' returnType=ReturnType
    ('precondition' precondition=Condition)?
    ('postcondition' postcondition=Condition)?;

//AC
ReturnType:
    type=ParameterType;

//AC
Condition:
    {Condition}
    condition=Expression;

//user added/defined operation

BaseType:
	name=("Number" | "String" | "Date" | "Boolean");


OntologyType:
	name=("Asset" | "Event" | "Role" | "Contract" | "DataTransfer" ); //

//AC
AResource:
	name="Resource"
;

//AC
//Resource:
	//Obligation |
	//Power |
	//OntologyType |
	//ACPolicy

//;

//AC
/*
 * ACPolicy:
	name=ID ('with' (controller+=Controller ',')*)?
	;
 */
//AC
ACPolicy:
	 ('with' 'Controller' (controller+=Controller ',')* (controller+=Controller))
	; 
	

//AC
Controller:
    controllerType=VariableDotExpression;


//AC
//accessedResource attribute or resource, attribute is not part of class resource
Rule:
	name=ID ':'  ((action=('Grant' | 'Revoke')) permission=Permission 'To' accessedRole=VariableDotExpression 'On' accessedResource=Resource  'by' controller=VariableDotExpression)
	 ;
//|
	//name=ID ':'  (action=Action permission= Permission 'To' accessedRole=VariableDotExpression 'On' 'obligations.' accessedResource = [Obligation] 'by' controller=VariableDotExpression)
	//name=ID ':'  ('GRNAT' | 'REVOKE' per= Permission 'TO' role=OntologyType("Role") 'ON' accessedResource=PointAtom) |
	//name=ID ':'  ('GRNAT' | 'REVOKE' per= Permission 'TO' role=OntologyType("Role") 'ON' accessedResource=OperationDotExpression)
	//(VariableDotExpression | Resource )

//AC
Resource:
 	{ResourceObligation} ('obligations.' resourceOp = [Obligation]) |
 	{ResourcePower} ( 'powers.' resourcePo = [Power]) |
 	{ResourceOntologyType} ( resourceOn = OntologyType) |
 	{ResourceACPolicy} (resourceAc=ACPolicy)|
 	{ResourceAttribute} (resourceAt=Attribute) |
 	{ResourceDot} (resourceDot= VariableDotExpression)|
	{ResourceOperation} (resourceOpe=Operation) //| {AResource} (aResource=AResource)
;


//AC
OperationDotExpression returns Ref:
	OperationRef ({OperationDotExpression.ref=current} "." tail=[Operation])*;

//AC
OperationRef returns Ref:
	{OperationRef} operation=ID;

//AC
Permission:
	name=('read' | 'write' | 'all' | 'transfer');


//AC - To differentiate a third party role from a role (contracting party)
ThirdParty:
	name=('thirdParty');



AttributeModifier:
	name=('Env');

Parameter:
	name=ID ':' type=ParameterType;

ParameterType:
	baseType=BaseType |
	domainType=[DomainType];

Variable:
	name=ID ':' type=[RegularType] ('with' attributes+=Assignment (',' attributes+=Assignment)*)?;

VariableDotExpression returns Ref:
	VariableRef ({VariableDotExpression.ref=current} "." tail=[Attribute])*;

VariableRef returns Ref:
	{VariableRef} variable=ID;

Assignment:
	{AssignExpression} name=ID ":=" (value=Expression)
	;


//sum returns AssignExpression:
// {AssignExpression} name=ID  op=":=" ({sum.left = current} (right=Expression))
 //;

// Assign should be used for ENV parameters or parameters of the contract. any variable initiate in the declaration are
//can not be used because the initial value will be assigned to the variable each time you trigger any events.
OAssignment:
	{OAssignExpression} name2= VariableDotExpression op=":=" (value=Expression);
	// |
	// Osum
// ;
// Osum returns OAssignExpression:
//	{OAssignExpression} name2= VariableDotExpression op=":=" ({Osum.left= current} ('+' | '-' | '*' | '/') (right=Expression))
//;

Double returns ecore::EDouble:
	INT '.' INT;

Date returns ecore::EDate:
  'Date' '(' STRING ')';

Expression: Or;

Or returns Expression:
	And ({Or.left=current} "or" right=And)*;

And returns Expression:
	Equality ({And.left=current} "and" right=Equality)*;

Equality returns Expression:
	Comparison ({Equality.left=current} op=("==" | "!=") right=Comparison)*;

Comparison returns Expression:
	Addition ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=Addition )*;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;

Multiplication returns Expression:
	PrimaryExpression (({Multi.left=current} '*' | {Div.left=current} '/' | {Mod.left=current} '%') right=PrimaryExpression)*;

PrimaryExpression returns Expression:
	{PrimaryExpressionRecursive} '(' inner=Expression ')' |
	{PrimaryExpressionFunctionCall} function=FunctionCall |
	{NegatedPrimaryExpression} "not" expression=PrimaryExpression |
	AtomicExpression
;

AtomicExpression returns Expression:
	{AtomicExpressionTrue} value="true" |
	{AtomicExpressionFalse} value="false" |
	{AtomicExpressionDouble} value=Double |
	{AtomicExpressionInt} value=INT |
	{AtomicExpressionDate} value= Date |
	{AtomicExpressionEnum} enumeration=[Enumeration]"("enumItem=[EnumItem]")" |
	{AtomicExpressionString} value=STRING |
	{AtomicExpressionParameter} value=VariableDotExpression
;

FunctionCall:
	MathFunction | StringFunction | DateFunction //| UserFunction
;

MathFunction returns FunctionCall:
	{TwoArgMathFunction} name=('Math.pow' | 'Math.max' | 'Math.min') '(' arg1=Expression ',' arg2=Expression ')' |
	{OneArgMathFunction} name=('Math.abs' | 'Math.floor' | 'Math.cbrt'
	| 'Math.ceil' | 'Math.exp' | 'Math.sign' | 'Math.sqrt') '(' arg1=Expression ')';

StringFunction returns FunctionCall:
  {ThreeArgStringFunction} name=('String.substring'|'String.replaceAll') '(' arg1=Expression ',' arg2=Expression ',' arg3=Expression ')' |
  {TwoArgStringFunction} name=('String.concat') '(' arg1=Expression ',' arg2=Expression ')' |
  {OneArgStringFunction} name=('String.toLowerCase'|'String.toUpperCase'|'String.trimEnd'|'String.trimStart'|'String.trim') '(' arg1=Expression ')';


DateFunction returns FunctionCall:
	{ThreeArgDateFunction} name='Date.add' '(' arg1=Expression ',' value=Expression ',' timeUnit=TimeUnit  ')' 
;

Obligation:
	name=ID ':' (trigger=Proposition '->')? ('O' | 'Obligation') '(' debtor=VariableDotExpression ',' creditor=VariableDotExpression ',' antecedent=Proposition ',' consequent=Proposition ')' ('with' 'Controller' controller= VariableDotExpression)?;


Power:
	name=ID ':' (trigger=Proposition '->')? ('P' | 'Power') '(' creditor=VariableDotExpression ',' debtor=VariableDotExpression ',' antecedent=Proposition ',' consequent=PowerFunction ')' ('with' 'Controller' controller= VariableDotExpression)?;

PowerFunction returns PowerFunction:
	{PFObligationSuspended} action = 'Suspended' '(' 'obligations.' norm = [Obligation] ')' | 
	{PFObligationResumed} action = 'Resumed' '(' 'obligations.' norm = [Obligation] ')' | 
	{PFObligationDischarged} action = 'Discharged' '(' 'obligations.' norm = [Obligation] ')' |
	{PFObligationTerminated} action = 'Terminated' '(' 'obligations.' norm = [Obligation] ')' |
	{PFObligationTriggered} action = 'Triggered' '(' 'obligations.' norm = [Obligation] ')' |
	//{PFPowerSuspended} action = 'Suspended_' '(' norm = [Power] ')' | 
	//{PFPowerResumed} action = 'Resumed_' '(' norm = [Power] ')' | 
	//{PFPowerTerminated} action = 'Terminated_' '(' norm = [Power] ')' |
	{PFContractSuspended} action = 'Suspended' '(' norm = 'self' ')' | 
	{PFContractResumed} action = 'Resumed' '(' norm = 'self' ')' |
	{PFContractTerminated} action = 'Terminated' '(' norm = 'self' ')';

Proposition: POr;

POr returns Proposition:
	PAnd ({POr.left=current} "or" right=PAnd)*;

PAnd returns Proposition:
	PEquality ({PAnd.left=current} "and" right=PEquality)*;

PEquality returns Proposition:
	PComparison ({PEquality.left=current} op=("==" | "!=") right=PComparison)*;

PComparison returns Proposition:
	PArithmetic ({PComparison.left=current} op=(">=" | "<=" | ">" | "<") right=PArithmetic)*;

PArithmetic returns Proposition:
    PAtomicExpression ({PArithmetic.left=current} op=("+" | "-" | "*" | "/" | "%") right=PAtomicExpression)*;

PAtomicExpression returns Proposition:
	{PAtomRecursive} '(' inner=Proposition ')' |
	{NegatedPAtom} 'not' negated=PAtomicExpression |
	{PAtomPredicate} predicateFunction=PredicateFunction |
	{PAtomFunction} function=OtherFunction |
	{PAtomEnum} enumeration=[Enumeration]"("enumItem=[EnumItem]")" |
	{PAtomVariable} variable=VariableDotExpression |
	{PAtomPredicateTrueLiteral} value='true' |
	{PAtomPredicateFalseLiteral} value='false' |
	{PAtomDoubleLiteral} value=Double |
	{PAtomIntLiteral} value=INT |
	{PAtomStringLiteral} value=STRING |
	{PAtomDateLiteral} value= Date;

PredicateFunction:
	{PredicateFunctionHappens} name='Happens' '(' event=Event')' |
	//{PredicateFunctionHappensData} name='HappensData' '(' data=Event ')' |
	{PredicateFunctionWHappensBefore} name='WhappensBefore' '(' event=Event ',' point=Point ')' |
	{PredicateFunctionSHappensBefore} name='ShappensBefore' '(' event=Event ',' point=Point ')' |
	{PredicateFunctionHappensWithin} name='HappensWithin' '(' event=Event ',' interval=Interval ')'|
	{PredicateFunctionWHappensBeforeEvent} name='WhappensBeforeE' '(' event1=Event ',' event2=Event ')' |
	{PredicateFunctionSHappensBeforeEvent} name='ShappensBeforeE' '(' event1=Event ',' event2=Event ')' |
	{PredicateFunctionHappensAfter} name='HappensAfter' '(' event=Event ',' point=Point ')' |
	{PredicateFunctionOccurs} name='Occurs' '(' situation=Situation ',' interval=Interval ')' |
	{PredicateFunctionAssignment} name='HappensAssign' '(' event=Event ',' (assignment+=OAssignment (';' assignment+=OAssignment )*)?')' |
	{PredicateFunctionAssignmentOnly} name='Assign' '(' (assignment+=OAssignment (';' assignment+=OAssignment )*)?')'
		;

OtherFunction:
	{PredicateFunctionIsEqual} name='IsEqual' '(' arg1=ID ',' arg2=ID ')' |
	{PredicateFunctionIsOwner} name='IsOwner' '(' arg1=ID ',' arg2=ID ')' |
	{PredicateFunctionCannotBeAssigned} name='CannotBeAssigned' '(' arg1=ID ')';

Event:
	VariableEvent |
	ObligationEvent |
	ContractEvent |
	PowerEvent
	| DataTransfer;  //Include Data as an Event type, AC

//AC
DataTransfer returns Event:
   {DataTransfer} name=ID variable=VariableDotExpression;


VariableEvent returns Event:
	{VariableEvent} variable=VariableDotExpression;

//AC
//VariableData returns Event:
	//{VariableData} variable=VariableDotExpression
//;


PowerEvent returns Event:
	{PowerEvent} eventName=PowerEventName '(' 'powers.' powerVariable=[Power] ')';

PowerEventName:
	'Triggered' | 'Activated' | 'Suspended' | 'Resumed' | 'Exerted' | 'Expired' | 'Terminated';

ObligationEvent returns Event:
	{ObligationEvent} eventName=ObligationEventName '(' 'obligations.' obligationVariable=[Obligation] ')';

ObligationEventName:
	'Triggered' | 'Activated' | 'Suspended' | 'Resumed' | 'Discharged' | 'Expired' | 'Fulfilled' | 'Violated' | 'Terminated';

ContractEvent returns Eselfvent:
	{ContractEvent} eventName=ContractEventName '(' 'self' ')';

ContractEventName:
	'Activated' | 'Suspended' | 'Resumed' | 'FulfilledObligations' | 'RevokedParty' | 'AssignedParty' | 'Terminated' | 'Rescinded';

Point:
	pointExpression=PointExpression;

PointExpression:
	PointFunction |
	PointAtom;

PointFunction returns PointExpression:
	{PointFunction} name=PointFunctionName '(' arg=PointExpression ',' value=Timevalue ',' timeUnit=TimeUnit ')';

PointFunctionName:
	'Date.add';

PointAtom returns PointExpression:
	{PointAtomParameterDotExpression} variable=VariableDotExpression | 
	{PointAtomObligationEvent} obligationEvent=ObligationEvent |
	{PointAtomContractEvent} contractEvent=ContractEvent |
	{PointAtomPowerEvent} powerEvent=PowerEvent;


Timevalue:
	{TimevalueInt} value=INT |
	{TimevalueVariable} variable=VariableDotExpression
;

TimeUnit:
	'seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'months' | 'years';

Interval:
	intervalExpression=IntervalExpression;

IntervalExpression:
	{IntervalFunction} 'Interval' '(' arg1=PointExpression ',' arg2=PointExpression ')' |
	{SituationExpression} situation=Situation;

Situation:
	ObligationState |
	ContractState |
	PowerState;

PowerState:
	stateName=PowerStateName '(' 'powers.' powerVariable=[Power] ')';

PowerStateName:
	'Create' | 'UnsuccessfulTermination' | 'Active' | 'InEffect' | 'Suspension' | 'SuccessfulTermination';

ObligationState:
	stateName=ObligationStateName '(' 'obligations.' obligationVariable=[Obligation] ')';

ObligationStateName:
	'Create' | 'Discharge' | 'Active' | 'InEffect' | 'Suspension' | 'Violation' | 'Fulfillment' | 'UnsuccessfulTermination';

ContractState:
	stateName=ContractStateName '(' 'self' ')';

ContractStateName:
	'Form' | 'UnAssign' | 'InEffect' | 'Suspension' | 'Rescission' | 'SuccessfulTermination' | 'UnsuccessfulTermination' | 'Active';

//Modification:
//	name=ID ':' (trigger=Proposition '->')? (function='Assign') '(' assignment=OAssignment')';
	// assignee=VariableDotExpression ":=" expression=Expression


